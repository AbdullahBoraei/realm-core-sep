#line 2 "query_flex.ll"
#include <stdint.h>


#define YY_INT_ALIGNED short int

/* A lexical scanner generated by flex */


/* %not-for-header */
/* %if-c-only */
/* %if-not-reentrant */

/* %endif */
/* %endif */
/* %ok-for-header */


#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 6
#define YY_FLEX_SUBMINOR_VERSION 4
#if YY_FLEX_SUBMINOR_VERSION > 0
#define FLEX_BETA
#endif


/* %if-c++-only */
/* %endif */

/* %if-c-only */

/* %endif */


/* %if-c-only */

/* %endif */


/* First, we deal with  platform-specific or compiler-specific issues. */

/* begin standard C headers. */
/* %if-c-only */
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdlib.h>
/* %endif */

/* %if-tables-serialization */
/* %endif */
/* end standard C headers. */

/* %if-c-or-c++ */
/* flex integer type definitions */

#ifndef FLEXINT_H
#define FLEXINT_H

/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */

#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L

/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
 * if you want the limit (max/min) macros for int types.
 */
#ifndef __STDC_LIMIT_MACROS
#define __STDC_LIMIT_MACROS 1
#endif

#include <inttypes.h>
typedef int8_t flex_int8_t;
typedef uint8_t flex_uint8_t;
typedef int16_t flex_int16_t;
typedef uint16_t flex_uint16_t;
typedef int32_t flex_int32_t;
typedef uint32_t flex_uint32_t;
#else
typedef signed char flex_int8_t;
typedef short int flex_int16_t;
typedef int flex_int32_t;
typedef unsigned char flex_uint8_t;
typedef unsigned short int flex_uint16_t;
typedef unsigned int flex_uint32_t;

/* Limits of integral types. */
#ifndef INT8_MIN
#define INT8_MIN (-128)
#endif
#ifndef INT16_MIN
#define INT16_MIN (-32767 - 1)
#endif
#ifndef INT32_MIN
#define INT32_MIN (-2147483647 - 1)
#endif
#ifndef INT8_MAX
#define INT8_MAX (127)
#endif
#ifndef INT16_MAX
#define INT16_MAX (32767)
#endif
#ifndef INT32_MAX
#define INT32_MAX (2147483647)
#endif
#ifndef UINT8_MAX
#define UINT8_MAX (255U)
#endif
#ifndef UINT16_MAX
#define UINT16_MAX (65535U)
#endif
#ifndef UINT32_MAX
#define UINT32_MAX (4294967295U)
#endif

#ifndef SIZE_MAX
#define SIZE_MAX (~(size_t)0)
#endif

#endif /* ! C99 */

#endif /* ! FLEXINT_H */

/* %endif */

/* begin standard C++ headers. */
/* %if-c++-only */
/* %endif */

/* TODO: this is always defined, so inline it */
#define yyconst const

#if defined(__GNUC__) && __GNUC__ >= 3
#define yynoreturn __attribute__((__noreturn__))
#else
#define yynoreturn
#endif

/* %not-for-header */
/* Returned upon end-of-file. */
#define YY_NULL 0
/* %ok-for-header */


/* %not-for-header */
/* Promotes a possibly negative, possibly signed char to an
 *   integer in range [0..255] for use as an array index.
 */
#define YY_SC_TO_UI(c) ((YY_CHAR)(c))
/* %ok-for-header */


/* %if-reentrant */
/* %endif */


/* %if-not-reentrant */


/* %endif */


/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN (yy_start) = 1 + 2 *
/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START (((yy_start)-1) / 2)
#define YYSTATE YY_START
/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart(yyin)
#define YY_END_OF_BUFFER_CHAR 0


/* Size of default input buffer. */
#ifndef YY_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k.
 * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
 * Ditto for the __ia64__ case accordingly.
 */
#define YY_BUF_SIZE 32768
#else
#define YY_BUF_SIZE 16384
#endif /* __ia64__ */
#endif


/* The state buf must be large enough to hold one state per character in the main buffer.
 */
#define YY_STATE_BUF_SIZE ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))


#ifndef YY_TYPEDEF_YY_BUFFER_STATE
#define YY_TYPEDEF_YY_BUFFER_STATE
typedef struct yy_buffer_state* YY_BUFFER_STATE;
#endif

#ifndef YY_TYPEDEF_YY_SIZE_T
#define YY_TYPEDEF_YY_SIZE_T
typedef size_t yy_size_t;
#endif

/* %if-not-reentrant */
extern int yyleng;
/* %endif */

/* %if-c-only */
/* %if-not-reentrant */
extern FILE *yyin, *yyout;
/* %endif */
/* %endif */


#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

#define YY_LESS_LINENO(n)
#define YY_LINENO_REWIND_TO(ptr)

/* Return all but the first "n" matched characters back to the input stream. */
#define yyless(n)                                                                                                    \
    do {                                                                                                             \
        /* Undo effects of setting up yytext. */                                                                     \
        int yyless_macro_arg = (n);                                                                                  \
        YY_LESS_LINENO(yyless_macro_arg);                                                                            \
        *yy_cp = (yy_hold_char);                                                                                     \
        YY_RESTORE_YY_MORE_OFFSET(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ;                      \
        YY_DO_BEFORE_ACTION; /* set up yytext again */                                                               \
    } while (0)
#define unput(c) yyunput(c, (yytext_ptr))


#ifndef YY_STRUCT_YY_BUFFER_STATE
#define YY_STRUCT_YY_BUFFER_STATE
struct yy_buffer_state {
    /* %if-c-only */
    FILE* yy_input_file;
    /* %endif */

    /* %if-c++-only */
    /* %endif */


    char* yy_ch_buf;  /* input buffer */
    char* yy_buf_pos; /* current position in input buffer */

    /* Size of input buffer in bytes, not including room for EOB
     * characters.
     */
    int yy_buf_size;

    /* Number of characters read into yy_ch_buf, not including EOB
     * characters.
     */
    int yy_n_chars;

    /* Whether we "own" the buffer - i.e., we know we created it,
     * and can realloc() it to grow it, and should free() it to
     * delete it.
     */
    int yy_is_our_buffer;

    /* Whether this is an "interactive" input source; if so, and
     * if we're using stdio for input, then we want to use getc()
     * instead of fread(), to make sure we stop fetching input after
     * each newline.
     */
    int yy_is_interactive;

    /* Whether we're considered to be at the beginning of a line.
     * If so, '^' rules will be active on the next match, otherwise
     * not.
     */
    int yy_at_bol;

    int yy_bs_lineno; /**< The line count. */
    int yy_bs_column; /**< The column count. */


    /* Whether to try to fill the input buffer when we reach the
     * end of it.
     */
    int yy_fill_buffer;

    int yy_buffer_status;

#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
    /* When an EOF's been seen but there's still some text to process
     * then we mark the buffer as YY_EOF_PENDING, to indicate that we
     * shouldn't try reading from the input source any more.  We might
     * still have a bunch of tokens to match, though, because of
     * possible backing-up.
     *
     * When we actually see the EOF, we change the status to "new"
     * (via yyrestart()), so that the user can continue scanning by
     * just pointing yyin at a new input file.
     */
#define YY_BUFFER_EOF_PENDING 2
};
#endif /* !YY_STRUCT_YY_BUFFER_STATE */

/* %if-c-only Standard (non-C++) definition */
/* %not-for-header */
/* %if-not-reentrant */

/* Stack of input buffers. */
static size_t yy_buffer_stack_top = 0;          /**< index of top of stack. */
static size_t yy_buffer_stack_max = 0;          /**< capacity of stack. */
static YY_BUFFER_STATE* yy_buffer_stack = NULL; /**< Stack as an array. */
/* %endif */
/* %ok-for-header */

/* %endif */


/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 *
 * Returns the top of the stack, or NULL.
 */
#define YY_CURRENT_BUFFER ((yy_buffer_stack) ? (yy_buffer_stack)[(yy_buffer_stack_top)] : NULL)
/* Same as previous macro, but useful when we know that the buffer stack is not
 * NULL or when we need an lvalue. For internal use only.
 */
#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]


/* %if-c-only Standard (non-C++) definition */

/* %if-not-reentrant */
/* %not-for-header */
/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;
static int yy_n_chars; /* number of characters read into yy_ch_buf */
int yyleng;

/* Points to current character in buffer. */
static char* yy_c_buf_p = NULL;
static int yy_init = 0;  /* whether we need to initialize */
static int yy_start = 0; /* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;
/* %ok-for-header */

/* %endif */

void yyrestart(FILE* input_file);
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer);
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size);
void yy_delete_buffer(YY_BUFFER_STATE b);
void yy_flush_buffer(YY_BUFFER_STATE b);
void yypush_buffer_state(YY_BUFFER_STATE new_buffer);
void yypop_buffer_state(void);


static void yyensure_buffer_stack(void);
static void yy_load_buffer_state(void);
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file);
#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER)


YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size);
YY_BUFFER_STATE yy_scan_string(const char* yy_str);
YY_BUFFER_STATE yy_scan_bytes(const char* bytes, int len);

/* %endif */

void* yyalloc(yy_size_t);
void* yyrealloc(void*, yy_size_t);
void yyfree(void*);


#define yy_new_buffer yy_create_buffer
#define yy_set_interactive(is_interactive)                                                                           \
    {                                                                                                                \
        if (!YY_CURRENT_BUFFER) {                                                                                    \
            yyensure_buffer_stack();                                                                                 \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                                          \
        }                                                                                                            \
        YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive;                                                \
    }
#define yy_set_bol(at_bol)                                                                                           \
    {                                                                                                                \
        if (!YY_CURRENT_BUFFER) {                                                                                    \
            yyensure_buffer_stack();                                                                                 \
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);                                          \
        }                                                                                                            \
        YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol;                                                                \
    }
#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)


/* %% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's & init go here */
/* Begin user sect3 */

#define yywrap() (/*CONSTCOND*/ 1)
#define YY_SKIP_YYWRAP

#define FLEX_DEBUG
typedef flex_uint8_t YY_CHAR;

FILE *yyin = NULL, *yyout = NULL;

typedef int yy_state_type;

extern int yylineno;
int yylineno = 1;

extern char* yytext;
#ifdef yytext_ptr
#undef yytext_ptr
#endif
#define yytext_ptr yytext


/* %% [1.5] DFA */


/* %if-c-only Standard (non-C++) definition */


static yy_state_type yy_get_previous_state(void);
static yy_state_type yy_try_NUL_trans(yy_state_type current_state);
static int yy_get_next_buffer(void);
static void yynoreturn yy_fatal_error(const char* msg);


/* %endif */


/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION                                                                                          \
    (yytext_ptr) = yy_bp;                                                                                            \
    /* %% [2.0] code to fiddle yytext and yyleng for yymore() goes here \ */                                         \
    yyleng = (int)(yy_cp - yy_bp);                                                                                   \
    (yy_hold_char) = *yy_cp;                                                                                         \
    *yy_cp = '\0';                                                                                                   \
    /* %% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \ */                                        \
    (yy_c_buf_p) = yy_cp;
/* %% [4.0] data tables for the DFA and the user's section 1 definitions go here */
#define YY_NUM_RULES 53
#define YY_END_OF_BUFFER 54
/* This struct is not used in this scanner,
   but its presence is necessary. */
struct yy_trans_info {
    flex_int32_t yy_verify;
    flex_int32_t yy_nxt;
};
static const flex_int16_t yy_accept[336] = {
    0,  0,  0,  54, 52, 1,  2,  12, 52, 51, 52, 52, 7,  52, 7,  42, 42, 5,  3,  6,  52, 51, 51, 51, 51, 51,
    51, 51, 51, 51, 51, 51, 51, 51, 52, 51, 51, 51, 51, 51, 51, 51, 51, 51, 52, 1,  2,  4,  0,  50, 0,  51,
    43, 10, 0,  49, 0,  0,  44, 0,  0,  47, 0,  47, 42, 0,  0,  8,  3,  9,  0,  0,  0,  0,  51, 51, 51, 51,
    51, 51, 51, 51, 51, 51, 51, 51, 3,  51, 51, 51, 51, 51, 51, 11, 51, 51, 0,  51, 51, 51, 51,

    0,  51, 51, 51, 51, 51, 51, 51, 51, 11, 0,  0,  0,  0,  0,  0,  47, 0,  46, 45, 0,  0,  0,  0,  0,  0,
    14, 10, 13, 25, 51, 51, 51, 51, 51, 51, 51, 51, 36, 51, 51, 37, 38, 51, 12, 51, 51, 51, 0,  0,  51, 51,
    33, 51, 51, 51, 51, 51, 51, 0,  0,  36, 37, 0,  47, 0,  32, 0,  29, 30, 0,  31, 51, 0,  51, 51, 26, 51,
    51, 51, 51, 51, 19, 51, 15, 38, 22, 0,  41, 34, 51, 51, 0,  51, 0,  0,  0,  0,  0,  27,

    51, 48, 0,  51, 51, 51, 51, 51, 35, 51, 51, 24, 51, 0,  0,  0,  0,  0,  0,  28, 51, 51, 51, 51, 51, 51,
    51, 51, 51, 0,  0,  0,  0,  51, 51, 51, 51, 51, 51, 51, 51, 51, 0,  0,  0,  0,  51, 51, 18, 51, 23, 17,
    51, 36, 51, 0,  0,  36, 0,  25, 51, 51, 51, 51, 0,  0,  0,  16, 26, 51, 51, 0,  0,  41, 51, 51, 0,  0,
    0,  51, 51, 0,  0,  41, 51, 20, 0,  0,  21, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,

    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  40, 0,  0,  0,  0,  0,  0,
    0,  0,  0,  0,  0,  0,  0,  39, 0};

static const YY_CHAR yy_ec[256] = {
    0,  1,  1,  1,  1,  1,  1,  1,  1,  2,  3,  1,  1,  2,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  2,  4,  5,  1,  6,  1,  7,  8,  9,  10, 1,  11, 12, 13, 14, 15, 16, 17, 17, 17, 18, 17, 19, 17,
    17, 17, 20, 1,  21, 22, 23, 1,  24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 34, 41, 42,
    43, 44, 34, 45, 46, 47, 34, 48, 49, 50, 1,  51, 1,  52, 53, 54, 55,

    56, 57, 58, 59, 60, 34, 61, 62, 63, 64, 65, 66, 34, 67, 68, 69, 70, 71, 72, 73, 74, 75, 1,  76, 1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,

    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,
    1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1};

static const YY_CHAR yy_meta[77] = {0, 1, 1, 1, 1, 2, 3, 1, 4, 1, 1, 5, 1, 3, 1, 5, 6, 6, 6, 6, 1, 1, 5, 1, 1, 6,
                                    6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1, 1, 1, 3,
                                    6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 1};

static const flex_int16_t yy_base[405] = {
    0,   0,   0,   727, 728, 724, 722, 702, 72,  62,  716, 74,  728, 69,  73,  80,  87,  88,  91,  700, 76,
    82,  96,  69,  98,  81,  70,  0,   97,  99,  116, 96,  99,  154, 667, 136, 113, 123, 102, 155, 136, 117,
    116, 650, 643, 716, 714, 728, 142, 728, 197, 0,   192, 728, 143, 728, 219, 200, 214, 159, 137, 222, 239,
    263, 277, 286, 0,   728, 728, 728, 645, 650, 127, 124, 678, 198, 195, 208, 695, 211, 209, 206, 217, 216,
    239, 248, 230, 268, 274, 262, 272, 147, 276, 0,   276, 273, 304, 311, 328, 271, 272,

    662, 649, 296, 295, 137, 655, 291, 292, 649, 728, 0,   0,   309, 311, 360, 367, 371, 375, 379, 0,   650,
    637, 633, 641, 629, 640, 0,   0,   0,   326, 697, 339, 338, 347, 359, 361, 362, 363, 373, 379, 376, 0,
    0,   672, 0,   375, 671, 369, 397, 407, 390, 392, 728, 390, 643, 689, 641, 393, 641, 0,   0,   401, 728,
    423, 434, 438, 728, 631, 728, 728, 638, 728, 405, 688, 406, 420, 418, 426, 415, 433, 434, 427, 0,   423,
    0,   0,   0,   459, 463, 427, 428, 442, 0,   683, 0,   0,   435, 484, 622, 728,

    455, 728, 685, 443, 455, 457, 458, 464, 464, 465, 473, 0,   468, 0,   0,   0,   0,   474, 500, 728, 479,
    468, 482, 486, 496, 482, 485, 485, 500, 0,   0,   489, 543, 500, 509, 502, 512, 504, 516, 520, 506, 527,
    0,   0,   510, 549, 540, 531, 0,   539, 0,   0,   550, 0,   546, 0,   0,   728, 569, 0,   549, 552, 557,
    564, 0,   0,   576, 0,   0,   569, 572, 0,   0,   595, 574, 558, 0,   0,   603, 559, 575, 0,   0,   616,
    580, 0,   0,   676, 0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   675, 0,

    0,   0,   0,   0,   0,   0,   0,   0,   674, 0,   0,   0,   0,   0,   0,   0,   0,   676, 672, 728, 0,
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   674, 728, 728, 636, 641, 648, 677, 676, 675, 674,
    673, 654, 672, 671, 670, 669, 668, 667, 666, 665, 664, 663, 662, 661, 660, 659, 658, 657, 656, 652, 651,
    644, 640, 639, 634, 624, 623, 619, 610, 601, 537, 531, 530, 478, 458, 404, 363, 362, 361, 359, 358, 357,
    355, 354, 353, 350, 347, 346, 344, 312, 301, 271, 259, 256, 246, 231, 223, 208,

    187, 175, 111, 78};

static const flex_int16_t yy_def[405] = {
    0,   335, 1,   335, 335, 335, 335, 335, 336, 337, 335, 338, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 335, 337, 337, 337, 337, 337, 337, 337,
    337, 337, 335, 335, 335, 335, 336, 335, 335, 337, 337, 335, 338, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 339, 335, 335, 335, 335, 335, 335, 335, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337,
    337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 335, 337, 337, 337, 337,

    335, 337, 337, 337, 337, 337, 337, 337, 337, 335, 340, 341, 335, 335, 335, 335, 335, 335, 335, 339, 335,
    335, 335, 335, 335, 335, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337,
    337, 337, 337, 337, 337, 337, 335, 335, 337, 337, 335, 337, 337, 337, 337, 337, 337, 342, 343, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 337, 344, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337,
    337, 337, 337, 335, 335, 337, 337, 337, 345, 337, 346, 347, 335, 335, 335, 335,

    337, 335, 344, 337, 337, 337, 337, 337, 337, 337, 337, 337, 337, 348, 349, 350, 351, 335, 335, 335, 337,
    337, 337, 337, 337, 337, 337, 337, 337, 352, 353, 335, 335, 337, 337, 337, 337, 337, 337, 337, 337, 337,
    354, 355, 335, 335, 337, 337, 337, 337, 337, 337, 337, 337, 337, 356, 357, 335, 335, 337, 337, 337, 337,
    337, 358, 359, 335, 337, 337, 337, 337, 360, 361, 335, 337, 337, 362, 363, 335, 337, 337, 364, 365, 335,
    337, 337, 366, 335, 337, 367, 368, 369, 370, 371, 372, 373, 374, 375, 335, 376,

    377, 378, 379, 380, 381, 382, 383, 384, 335, 385, 386, 387, 388, 389, 390, 391, 392, 335, 335, 335, 393,
    394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 335, 335, 0,   335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,

    335, 335, 335, 335};

static const flex_int16_t yy_nxt[805] = {
    0,   4,   5,   6,   7,   8,   9,   10,  11,  12,  12,  13,  12,  13,  14,  4,   15,  16,  16,  16,  4,
    17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  27,  28,  27,  27,  29,  27,  30,  31,  27,  27,
    32,  33,  27,  27,  27,  27,  34,  4,   4,   27,  35,  36,  23,  24,  25,  37,  27,  27,  38,  27,  29,
    27,  39,  40,  27,  27,  41,  42,  43,  27,  27,  27,  27,  27,  44,  49,  52,  52,  52,  52,  55,  57,
    333, 58,  58,  58,  58,  61,  61,  61,  61,  62,  63,  84,  64,  64,  64,  64,  62,

    63,  59,  64,  64,  64,  64,  60,  80,  65,  67,  47,  67,  68,  69,  78,  65,  332, 74,  83,  75,  50,
    85,  56,  76,  79,  66,  81,  70,  59,  71,  82,  88,  60,  80,  86,  65,  93,  94,  72,  87,  89,  79,
    65,  73,  83,  77,  49,  85,  90,  76,  55,  79,  66,  81,  91,  95,  100, 82,  88,  92,  87,  114, 93,
    95,  96,  86,  97,  89,  79,  98,  98,  98,  98,  77,  104, 90,  93,  76,  123, 89,  331, 107, 108, 125,
    144, 92,  124, 90,  114, 145, 50,  56,  330, 126, 99,  106, 113, 102, 92,  103,

    155, 48,  93,  76,  48,  145, 89,  52,  52,  52,  52,  48,  48,  329, 90,  61,  61,  61,  61,  105, 100,
    130, 113, 54,  92,  128, 54,  63,  328, 58,  58,  58,  58,  54,  54,  128, 327, 61,  61,  61,  61,  132,
    65,  136, 129, 48,  133, 134, 130, 48,  115, 326, 128, 48,  116, 116, 116, 116, 135, 139, 48,  325, 128,
    48,  324, 48,  111, 54,  132, 65,  136, 54,  133, 134, 137, 54,  323, 115, 117, 117, 117, 117, 54,  138,
    135, 54,  139, 54,  112, 62,  63,  115, 64,  64,  64,  64,  118, 139, 118, 142,

    138, 119, 119, 119, 119, 65,  322, 143, 140, 138, 141, 146, 147, 148, 151, 152, 148, 319, 115, 149, 149,
    149, 149, 128, 139, 142, 98,  98,  98,  98,  138, 148, 65,  143, 140, 152, 141, 146, 162, 148, 152, 152,
    148, 98,  98,  98,  98,  150, 163, 318, 128, 317, 316, 157, 173, 315, 154, 148, 314, 313, 312, 158, 310,
    309, 308, 162, 307, 306, 305, 129, 164, 175, 164, 177, 163, 165, 165, 165, 165, 166, 176, 173, 116, 116,
    116, 116, 117, 117, 117, 117, 119, 119, 119, 119, 119, 119, 119, 119, 175, 115,

    177, 178, 179, 180, 181, 182, 176, 183, 184, 304, 186, 187, 149, 149, 149, 149, 150, 188, 190, 188, 191,
    191, 189, 189, 189, 189, 115, 178, 179, 181, 181, 181, 182, 197, 183, 184, 186, 187, 165, 165, 165, 165,
    201, 204, 205, 191, 206, 191, 190, 165, 165, 165, 165, 198, 198, 198, 198, 192, 207, 208, 197, 209, 210,
    303, 211, 212, 213, 213, 201, 204, 210, 205, 218, 206, 189, 189, 189, 189, 189, 189, 189, 189, 221, 302,
    222, 207, 208, 223, 210, 210, 211, 212, 213, 213, 224, 225, 226, 209, 218, 198,

    198, 198, 198, 227, 227, 228, 232, 219, 229, 221, 222, 234, 235, 237, 223, 233, 233, 233, 233, 236, 224,
    225, 238, 226, 239, 240, 219, 241, 242, 227, 227, 245, 228, 232, 229, 300, 299, 247, 234, 235, 237, 248,
    298, 249, 250, 236, 251, 252, 253, 238, 239, 240, 254, 241, 255, 242, 258, 245, 233, 233, 233, 233, 246,
    247, 259, 259, 259, 259, 248, 249, 260, 250, 251, 261, 252, 253, 262, 263, 264, 254, 268, 255, 269, 258,
    259, 259, 259, 259, 267, 270, 271, 274, 274, 274, 274, 275, 276, 260, 280, 261,

    281, 285, 262, 286, 263, 264, 297, 268, 289, 269, 274, 274, 274, 274, 279, 296, 270, 271, 284, 284, 284,
    284, 275, 276, 295, 280, 281, 285, 294, 293, 286, 284, 284, 284, 284, 289, 48,  48,  48,  292, 48,  48,
    48,  51,  290, 288, 51,  51,  54,  287, 54,  54,  54,  54,  54,  203, 283, 282, 203, 203, 203, 278, 277,
    273, 272, 266, 265, 257, 256, 244, 243, 54,  48,  231, 230, 217, 216, 214, 196, 195, 161, 160, 120, 334,
    321, 320, 311, 301, 291, 202, 220, 215, 202, 200, 199, 194, 129, 193, 185, 129,

    185, 174, 172, 171, 170, 169, 168, 167, 159, 156, 127, 153, 131, 127, 122, 121, 46,  45,  110, 109, 101,
    69,  53,  47,  46,  45,  335, 3,   335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,

    335, 335, 335, 335};

static const flex_int16_t yy_chk[805] = {
    0,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   8,   9,   9,   9,   9,   11,  13,
    404, 13,  13,  13,  13,  14,  14,  14,  14,  15,  15,  26,  15,  15,  15,  15,  16,

    16,  13,  16,  16,  16,  16,  13,  23,  15,  17,  17,  18,  18,  18,  22,  16,  403, 21,  25,  21,  8,
    26,  11,  21,  22,  15,  24,  20,  13,  20,  24,  29,  13,  23,  28,  15,  31,  32,  20,  38,  30,  36,
    16,  20,  25,  21,  48,  37,  30,  21,  54,  22,  15,  24,  30,  41,  42,  24,  29,  30,  28,  60,  31,
    32,  33,  38,  33,  30,  36,  33,  33,  33,  33,  35,  37,  30,  40,  35,  72,  39,  402, 41,  42,  73,
    91,  30,  72,  39,  60,  91,  48,  54,  401, 73,  33,  40,  59,  35,  39,  35,

    105, 50,  40,  35,  50,  105, 39,  52,  52,  52,  52,  50,  50,  400, 39,  57,  57,  57,  57,  39,  33,
    76,  59,  56,  39,  75,  56,  58,  399, 58,  58,  58,  58,  56,  56,  77,  398, 61,  61,  61,  61,  79,
    58,  83,  75,  50,  80,  81,  76,  50,  61,  397, 75,  50,  62,  62,  62,  62,  82,  86,  50,  396, 77,
    50,  395, 50,  50,  56,  79,  58,  83,  56,  80,  81,  84,  56,  394, 61,  63,  63,  63,  63,  56,  85,
    82,  56,  86,  56,  56,  64,  64,  63,  64,  64,  64,  64,  65,  87,  65,  89,

    84,  65,  65,  65,  65,  64,  393, 90,  88,  85,  88,  92,  94,  95,  99,  100, 94,  392, 63,  96,  96,
    96,  96,  103, 87,  89,  97,  97,  97,  97,  104, 107, 64,  90,  88,  108, 88,  92,  113, 95,  99,  100,
    94,  98,  98,  98,  98,  98,  114, 391, 103, 390, 389, 107, 130, 388, 104, 107, 387, 386, 385, 108, 384,
    383, 382, 113, 381, 380, 379, 103, 115, 132, 115, 134, 114, 115, 115, 115, 115, 116, 133, 130, 116, 116,
    116, 116, 117, 117, 117, 117, 118, 118, 118, 118, 119, 119, 119, 119, 132, 117,

    134, 135, 136, 137, 138, 139, 133, 140, 141, 378, 146, 148, 149, 149, 149, 149, 149, 150, 151, 150, 152,
    158, 150, 150, 150, 150, 117, 135, 136, 137, 138, 154, 139, 162, 140, 141, 146, 148, 164, 164, 164, 164,
    173, 175, 176, 151, 177, 152, 158, 165, 165, 165, 165, 166, 166, 166, 166, 154, 178, 179, 162, 180, 181,
    377, 182, 184, 190, 191, 173, 175, 192, 176, 197, 177, 188, 188, 188, 188, 189, 189, 189, 189, 201, 376,
    204, 178, 179, 205, 180, 181, 182, 184, 190, 191, 206, 207, 208, 192, 197, 198,

    198, 198, 198, 209, 210, 211, 218, 198, 213, 201, 204, 221, 222, 224, 205, 219, 219, 219, 219, 223, 206,
    207, 225, 208, 226, 227, 198, 228, 229, 209, 210, 232, 211, 218, 213, 375, 374, 234, 221, 222, 224, 235,
    373, 236, 237, 223, 238, 239, 240, 225, 226, 227, 241, 228, 242, 229, 245, 232, 233, 233, 233, 233, 233,
    234, 246, 246, 246, 246, 235, 236, 247, 237, 238, 248, 239, 240, 250, 253, 255, 241, 261, 242, 262, 245,
    259, 259, 259, 259, 259, 263, 264, 267, 267, 267, 267, 270, 271, 247, 275, 248,

    276, 280, 250, 281, 253, 255, 372, 261, 285, 262, 274, 274, 274, 274, 274, 371, 263, 264, 279, 279, 279,
    279, 270, 271, 370, 275, 276, 280, 369, 368, 281, 284, 284, 284, 284, 285, 336, 336, 336, 367, 336, 336,
    336, 337, 366, 365, 337, 337, 338, 364, 338, 338, 338, 338, 338, 344, 363, 362, 344, 344, 344, 361, 360,
    359, 358, 357, 356, 355, 354, 353, 352, 351, 350, 349, 348, 347, 346, 345, 343, 342, 341, 340, 339, 333,
    319, 318, 309, 299, 288, 203, 199, 194, 174, 171, 168, 159, 157, 156, 155, 147,

    144, 131, 126, 125, 124, 123, 122, 121, 109, 106, 102, 101, 78,  74,  71,  70,  46,  45,  44,  43,  34,
    19,  10,  7,   6,   5,   3,   335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,
    335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335, 335,

    335, 335, 335, 335};

static yy_state_type yy_last_accepting_state;
static char* yy_last_accepting_cpos;

extern int yy_flex_debug;
int yy_flex_debug = 1;

static const flex_int16_t yy_rule_linenum[53] = {
    0,  29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
    56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 82};

/* The intent behind this definition is that it'll catch
 * any uses of REJECT which flex missed.
 */
#define REJECT reject_used_but_not_detected
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char* yytext;

#include <cerrno>
#include <climits>
#include <cstdlib>
#include <cstring> // strerror
#include <string>
#include "realm/parser/driver.hpp"
#include "realm/parser/query_bison.hpp"
#define YY_NO_UNISTD_H 1
#define YY_NO_INPUT 1


#define INITIAL 0


#ifndef YY_NO_UNISTD_H
/* Special case for "unistd.h", since it is non-ANSI. We include it way
 * down here because we want the user's section 1 to have been scanned first.
 * The user has a chance to override it with an option.
 */
/* %if-c-only */
#include <unistd.h>
/* %endif */
/* %if-c++-only */
/* %endif */
#endif


#ifndef YY_EXTRA_TYPE
#define YY_EXTRA_TYPE void*
#endif


/* %if-c-only Reentrant structure and macros (non-C++). */
/* %if-reentrant */
/* %if-c-only */

static int yy_init_globals(void);

/* %endif */
/* %if-reentrant */
/* %endif */
/* %endif End reentrant structures and macros. */

/* Accessor methods to globals.
   These are made visible to non-reentrant scanners for convenience. */


int yylex_destroy(void);


int yyget_debug(void);


void yyset_debug(int debug_flag);


YY_EXTRA_TYPE yyget_extra(void);


void yyset_extra(YY_EXTRA_TYPE user_defined);


FILE* yyget_in(void);


void yyset_in(FILE* _in_str);


FILE* yyget_out(void);


void yyset_out(FILE* _out_str);


int yyget_leng(void);


char* yyget_text(void);


int yyget_lineno(void);


void yyset_lineno(int _line_number);


/* %if-bison-bridge */
/* %endif */

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap(void);
#else
extern int yywrap(void);
#endif
#endif

/* %not-for-header */
#ifndef YY_NO_UNPUT

#endif
/* %ok-for-header */

/* %endif */

#ifndef yytext_ptr
static void yy_flex_strncpy(char*, const char*, int);
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char*);
#endif

#ifndef YY_NO_INPUT
/* %if-c-only Standard (non-C++) definition */
/* %not-for-header */
#ifdef __cplusplus
static int yyinput(void);
#else
static int input(void);
#endif
/* %ok-for-header */

/* %endif */
#endif


/* %if-c-only */


/* %endif */

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#ifdef __ia64__
/* On IA-64, the buffer size is 16k, not 8k */
#define YY_READ_BUF_SIZE 16384
#else
#define YY_READ_BUF_SIZE 8192
#endif /* __ia64__ */
#endif


/* Copy whatever the last rule matched to the standard output. */
#ifndef ECHO
/* %if-c-only Standard (non-C++) definition */
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO                                                                                                         \
    do {                                                                                                             \
        if (fwrite(yytext, (size_t)yyleng, 1, yyout)) {                                                              \
        }                                                                                                            \
    } while (0)
/* %endif */
/* %if-c++-only C++ definition */
/* %endif */
#endif


/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf, result, max_size)                                                                              \
    /* %% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \ */                          \
    if (YY_CURRENT_BUFFER_LVALUE->yy_is_interactive) {                                                               \
        int c = '*';                                                                                                 \
        int n;                                                                                                       \
        for (n = 0; n < max_size && (c = getc(yyin)) != EOF && c != '\n'; ++n)                                       \
            buf[n] = (char)c;                                                                                        \
        if (c == '\n')                                                                                               \
            buf[n++] = (char)c;                                                                                      \
        if (c == EOF && ferror(yyin))                                                                                \
            YY_FATAL_ERROR("input in flex scanner failed");                                                          \
        result = n;                                                                                                  \
    }                                                                                                                \
    else {                                                                                                           \
        errno = 0;                                                                                                   \
        while ((result = (int)fread(buf, 1, (yy_size_t)max_size, yyin)) == 0 && ferror(yyin)) {                      \
            if (errno != EINTR) {                                                                                    \
                YY_FATAL_ERROR("input in flex scanner failed");                                                      \
                break;                                                                                               \
            }                                                                                                        \
            errno = 0;                                                                                               \
            clearerr(yyin);                                                                                          \
        }                                                                                                            \
    }                                                                                                                \
                                                                                                                     \
    /* %if-c++-only C++ definition \ */                                                                              \
    /* %endif */

#endif


/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif


/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif


/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
/* %if-c-only */
#define YY_FATAL_ERROR(msg) yy_fatal_error(msg)
/* %endif */
/* %if-c++-only */
/* %endif */
#endif


/* %if-tables-serialization structures and prototypes */
/* %not-for-header */
/* %ok-for-header */

/* %not-for-header */
/* %tables-yydmap generated elements */
/* %endif */
/* end tables serialization structures and prototypes */

/* %ok-for-header */


/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL_IS_OURS 1
/* %if-c-only Standard (non-C++) definition */


extern int yylex(void);

#define YY_DECL int yylex(void)
/* %endif */
/* %if-c++-only C++ definition */
/* %endif */
#endif /* !YY_DECL */


/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif


/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK /*LINTED*/ break;
#endif


/* %% [6.0] YY_RULE_SETUP definition goes here */
#define YY_RULE_SETUP YY_USER_ACTION


/* %not-for-header */
/** The main scanner function which does all the work.
 */
YY_DECL
{
    yy_state_type yy_current_state;
    char *yy_cp, *yy_bp;
    int yy_act;


    if (!(yy_init)) {
        (yy_init) = 1;

#ifdef YY_USER_INIT
        YY_USER_INIT;
#endif


        if (!(yy_start))
            (yy_start) = 1; /* first start state */

        if (!yyin)
            /* %if-c-only */
            yyin = stdin;
        /* %endif */
        /* %if-c++-only */
        /* %endif */

        if (!yyout)
            /* %if-c-only */
            yyout = stdout;
        /* %endif */
        /* %if-c++-only */
        /* %endif */

        if (!YY_CURRENT_BUFFER) {
            yyensure_buffer_stack();
            YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
        }

        yy_load_buffer_state();
    }

    {
        /* %% [7.0] user's declarations go here */


        while (/*CONSTCOND*/ 1) /* loops until end-of-file is reached */
        {
            /* %% [8.0] yymore()-related code goes here */
            yy_cp = (yy_c_buf_p);

            /* Support of yytext. */
            *yy_cp = (yy_hold_char);

            /* yy_bp points to the position in yy_ch_buf of the start of
             * the current run.
             */
            yy_bp = yy_cp;

            /* %% [9.0] code to set up and find next match goes here */
            yy_current_state = (yy_start);
        yy_match:
            do {
                YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
                if (yy_accept[yy_current_state]) {
                    (yy_last_accepting_state) = yy_current_state;
                    (yy_last_accepting_cpos) = yy_cp;
                }
                while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
                    yy_current_state = (int)yy_def[yy_current_state];
                    if (yy_current_state >= 336)
                        yy_c = yy_meta[yy_c];
                }
                yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
                ++yy_cp;
            } while (yy_current_state != 335);
            yy_cp = (yy_last_accepting_cpos);
            yy_current_state = (yy_last_accepting_state);

        yy_find_action:
            /* %% [10.0] code to find the action number goes here */
            yy_act = yy_accept[yy_current_state];

            YY_DO_BEFORE_ACTION;

            /* %% [11.0] code for yylineno update goes here */


        do_action: /* This label is used only to access EOF actions. */

            /* %% [12.0] debug code goes here */
            if (yy_flex_debug) {
                if (yy_act == 0)
                    fprintf(stderr, "--scanner backing up\n");
                else if (yy_act < 53)
                    fprintf(stderr, "--accepting rule at line %ld (\"%s\")\n", (long)yy_rule_linenum[yy_act], yytext);
                else if (yy_act == 53)
                    fprintf(stderr, "--accepting default rule (\"%s\")\n", yytext);
                else if (yy_act == 54)
                    fprintf(stderr, "--(end of buffer or a NUL)\n");
                else
                    fprintf(stderr, "--EOF (start condition %d)\n", YY_START);
            }

            switch (yy_act) { /* beginning of action switch */
                              /* %% [13.0] actions go here */
                case 0:       /* must back up */
                    /* undo the effects of YY_DO_BEFORE_ACTION */
                    *yy_cp = (yy_hold_char);
                    yy_cp = (yy_last_accepting_cpos);
                    yy_current_state = (yy_last_accepting_state);
                    goto yy_find_action;

                case 1:
                    YY_RULE_SETUP;
                    YY_BREAK
                case 2:
                    /* rule 2 can match eol */
                    YY_RULE_SETUP;
                    YY_BREAK
                case 3:
                    YY_RULE_SETUP
                    return yy::parser::make_EQUAL();
                    YY_BREAK
                case 4:
                    YY_RULE_SETUP
                    return yy::parser::make_NOT_EQUAL();
                    YY_BREAK
                case 5:
                    YY_RULE_SETUP
                    return yy::parser::make_LESS();
                    YY_BREAK
                case 6:
                    YY_RULE_SETUP
                    return yy::parser::make_GREATER();
                    YY_BREAK
                case 7:
                    YY_RULE_SETUP
                    return yytext[0];
                    YY_BREAK
                case 8:
                    YY_RULE_SETUP
                    return yy::parser::make_LESS_EQUAL();
                    YY_BREAK
                case 9:
                    YY_RULE_SETUP
                    return yy::parser::make_GREATER_EQUAL();
                    YY_BREAK
                case 10:
                    YY_RULE_SETUP
                    return yy::parser::make_AND();
                    YY_BREAK
                case 11:
                    YY_RULE_SETUP
                    return yy::parser::make_OR();
                    YY_BREAK
                case 12:
                    YY_RULE_SETUP
                    return yy::parser::make_NOT();
                    YY_BREAK
                case 13:
                    YY_RULE_SETUP
                    return yy::parser::make_ANY();
                    YY_BREAK
                case 14:
                    YY_RULE_SETUP
                    return yy::parser::make_ALL();
                    YY_BREAK
                case 15:
                    YY_RULE_SETUP
                    return yy::parser::make_NONE();
                    YY_BREAK
                case 16:
                    YY_RULE_SETUP
                    return yy::parser::make_BEGINSWITH(yytext);
                    YY_BREAK
                case 17:
                    YY_RULE_SETUP
                    return yy::parser::make_ENDSWITH(yytext);
                    YY_BREAK
                case 18:
                    YY_RULE_SETUP
                    return yy::parser::make_CONTAINS(yytext);
                    YY_BREAK
                case 19:
                    YY_RULE_SETUP
                    return yy::parser::make_LIKE(yytext);
                    YY_BREAK
                case 20:
                    YY_RULE_SETUP
                    return yy::parser::make_TRUEPREDICATE();
                    YY_BREAK
                case 21:
                    YY_RULE_SETUP
                    return yy::parser::make_FALSEPREDICATE();
                    YY_BREAK
                case 22:
                    YY_RULE_SETUP
                    return yy::parser::make_SORT();
                    YY_BREAK
                case 23:
                    YY_RULE_SETUP
                    return yy::parser::make_DISTINCT();
                    YY_BREAK
                case 24:
                    YY_RULE_SETUP
                    return yy::parser::make_LIMIT();
                    YY_BREAK
                case 25:
                    YY_RULE_SETUP
                    return yy::parser::make_ASCENDING();
                    YY_BREAK
                case 26:
                    YY_RULE_SETUP
                    return yy::parser::make_DESCENDING();
                    YY_BREAK
                case 27:
                    YY_RULE_SETUP
                    return yy::parser::make_SIZE();
                    YY_BREAK
                case 28:
                    YY_RULE_SETUP
                    return yy::parser::make_COUNT();
                    YY_BREAK
                case 29:
                    YY_RULE_SETUP
                    return yy::parser::make_MAX();
                    YY_BREAK
                case 30:
                    YY_RULE_SETUP
                    return yy::parser::make_MIN();
                    YY_BREAK
                case 31:
                    YY_RULE_SETUP
                    return yy::parser::make_SUM();
                    YY_BREAK
                case 32:
                    YY_RULE_SETUP
                    return yy::parser::make_AVG();
                    YY_BREAK
                case 33:
                    YY_RULE_SETUP
                    return yy::parser::make_CASE();
                    YY_BREAK
                case 34:
                    YY_RULE_SETUP
                    return yy::parser::make_TRUE();
                    YY_BREAK
                case 35:
                    YY_RULE_SETUP
                    return yy::parser::make_FALSE();
                    YY_BREAK
                case 36:
                    YY_RULE_SETUP
                    return yy::parser::make_INFINITY(yytext);
                    YY_BREAK
                case 37:
                    YY_RULE_SETUP
                    return yy::parser::make_NAN(yytext);
                    YY_BREAK
                case 38:
                    YY_RULE_SETUP
                    return yy::parser::make_NULL_VAL();
                    YY_BREAK
                case 39:
                    YY_RULE_SETUP
                    return yy::parser::make_UUID(yytext);
                    YY_BREAK
                case 40:
                    YY_RULE_SETUP
                    return yy::parser::make_OID(yytext);
                    YY_BREAK
                case 41:
                    YY_RULE_SETUP
                    return yy::parser::make_TIMESTAMP(yytext);
                    YY_BREAK
                case 42:
                    YY_RULE_SETUP
                    return yy::parser::make_NATURAL0(yytext);
                    YY_BREAK
                case 43:
                    YY_RULE_SETUP
                    return yy::parser::make_ARG(yytext);
                    YY_BREAK
                case 44:
                    YY_RULE_SETUP
                    return yy::parser::make_NUMBER(yytext);
                    YY_BREAK
                case 45:
                    YY_RULE_SETUP
                    return yy::parser::make_NUMBER(yytext);
                    YY_BREAK
                case 46:
                    YY_RULE_SETUP
                    return yy::parser::make_FLOAT(yytext);
                    YY_BREAK
                case 47:
                    YY_RULE_SETUP
                    return yy::parser::make_FLOAT(yytext);
                    YY_BREAK
                case 48:
                    YY_RULE_SETUP
                    return yy::parser::make_BASE64(yytext);
                    YY_BREAK
                case 49:
                    /* rule 49 can match eol */
                    YY_RULE_SETUP
                    return yy::parser::make_STRING(yytext);
                    YY_BREAK
                case 50:
                    /* rule 50 can match eol */
                    YY_RULE_SETUP
                    return yy::parser::make_STRING(yytext);
                    YY_BREAK
                case 51:
                    YY_RULE_SETUP
                    return yy::parser::make_ID(yytext);
                    YY_BREAK
                case 52:
                    YY_RULE_SETUP
                    {
                        throw yy::parser::syntax_error("invalid character: " + std::string(yytext));
                    }
                    YY_BREAK
                case YY_STATE_EOF(INITIAL):
                    return yy::parser::make_END();
                    YY_BREAK
                case 53:
                    YY_RULE_SETUP
                    ECHO;
                    YY_BREAK

                case YY_END_OF_BUFFER: {
                    /* Amount of text matched not including the EOB char. */
                    int yy_amount_of_matched_text = (int)(yy_cp - (yytext_ptr)) - 1;

                    /* Undo the effects of YY_DO_BEFORE_ACTION. */
                    *yy_cp = (yy_hold_char);
                    YY_RESTORE_YY_MORE_OFFSET

                    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW) {
                        /* We're scanning a new file or input source.  It's
                         * possible that this happened because the user
                         * just pointed yyin at a new source and called
                         * yylex().  If so, then we have to assure
                         * consistency between YY_CURRENT_BUFFER and our
                         * globals.  Here is the right place to do so, because
                         * this is the first action (other than possibly a
                         * back-up) that will match for the new input source.
                         */
                        (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
                        /* %if-c-only */
                        YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
                        /* %endif */
                        /* %if-c++-only */
                        /* %endif */
                        YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
                    }

                    /* Note that here we test for yy_c_buf_p "<=" to the position
                     * of the first EOB in the buffer, since yy_c_buf_p will
                     * already have been incremented past the NUL character
                     * (since all states make transitions on EOB to the
                     * end-of-buffer state).  Contrast this with the test
                     * in input().
                     */
                    if ((yy_c_buf_p) <=
                        &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)]) { /* This was really a NUL. */
                        yy_state_type yy_next_state;

                        (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                        yy_current_state = yy_get_previous_state();

                        /* Okay, we're now positioned to make the NUL
                         * transition.  We couldn't have
                         * yy_get_previous_state() go ahead and do it
                         * for us because it doesn't know how to deal
                         * with the possibility of jamming (and we don't
                         * want to build jamming into it because then it
                         * will run more slowly).
                         */

                        yy_next_state = yy_try_NUL_trans(yy_current_state);

                        yy_bp = (yytext_ptr) + YY_MORE_ADJ;

                        if (yy_next_state) {
                            /* Consume the NUL. */
                            yy_cp = ++(yy_c_buf_p);
                            yy_current_state = yy_next_state;
                            goto yy_match;
                        }

                        else {
                            /* %% [14.0] code to do back-up for compressed tables and set up yy_cp goes here */
                            yy_cp = (yy_last_accepting_cpos);
                            yy_current_state = (yy_last_accepting_state);
                            goto yy_find_action;
                        }
                    }

                    else
                        switch (yy_get_next_buffer()) {
                            case EOB_ACT_END_OF_FILE: {
                                (yy_did_buffer_switch_on_eof) = 0;

                                if (yywrap()) {
                                    /* Note: because we've taken care in
                                     * yy_get_next_buffer() to have set up
                                     * yytext, we can now set up
                                     * yy_c_buf_p so that if some total
                                     * hoser (like flex itself) wants to
                                     * call the scanner after we return the
                                     * YY_NULL, it'll still work - another
                                     * YY_NULL will get returned.
                                     */
                                    (yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;

                                    yy_act = YY_STATE_EOF(YY_START);
                                    goto do_action;
                                }

                                else {
                                    if (!(yy_did_buffer_switch_on_eof))
                                        YY_NEW_FILE;
                                }
                                break;
                            }

                            case EOB_ACT_CONTINUE_SCAN:
                                (yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;

                                yy_current_state = yy_get_previous_state();

                                yy_cp = (yy_c_buf_p);
                                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                                goto yy_match;

                            case EOB_ACT_LAST_MATCH:
                                (yy_c_buf_p) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];

                                yy_current_state = yy_get_previous_state();

                                yy_cp = (yy_c_buf_p);
                                yy_bp = (yytext_ptr) + YY_MORE_ADJ;
                                goto yy_find_action;
                        }
                    break;
                }

                default:
                    YY_FATAL_ERROR("fatal flex scanner internal error--no action found");
            } /* end of action switch */
        }     /* end of scanning one token */
    }         /* end of user's declarations */
} /* end of yylex */
/* %ok-for-header */


/* %if-c++-only */
/* %not-for-header */
/* %ok-for-header */

/* %endif */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */
/* %if-c-only */
static int yy_get_next_buffer(void)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    char* dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
    char* source = (yytext_ptr);
    int number_to_move, i;
    int ret_val;

    if ((yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1])
        YY_FATAL_ERROR("fatal flex scanner internal error--end of buffer missed");

    if (YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0) { /* Don't try to fill the buffer, so this is an EOF. */
        if ((yy_c_buf_p) - (yytext_ptr)-YY_MORE_ADJ == 1) {
            /* We matched a single character, the EOB, so
             * treat this as a final EOF.
             */
            return EOB_ACT_END_OF_FILE;
        }

        else {
            /* We matched some text prior to the EOB, first
             * process it.
             */
            return EOB_ACT_LAST_MATCH;
        }
    }

    /* Try to read more data. */

    /* First move last chars to start of buffer. */
    number_to_move = (int)((yy_c_buf_p) - (yytext_ptr)-1);

    for (i = 0; i < number_to_move; ++i)
        *(dest++) = *(source++);

    if (YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING)
        /* don't do the read, it's not guaranteed to return an EOF,
         * just force an EOF
         */
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;

    else {
        int num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;

        while (num_to_read <= 0) { /* Not enough room in the buffer - grow it. */

            /* just a shorter name for the current buffer */
            YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;

            int yy_c_buf_p_offset = (int)((yy_c_buf_p)-b->yy_ch_buf);

            if (b->yy_is_our_buffer) {
                int new_size = b->yy_buf_size * 2;

                if (new_size <= 0)
                    b->yy_buf_size += b->yy_buf_size / 8;
                else
                    b->yy_buf_size *= 2;

                b->yy_ch_buf = (char*)
                    /* Include room in for 2 EOB chars. */
                    yyrealloc((void*)b->yy_ch_buf, (yy_size_t)(b->yy_buf_size + 2));
            }
            else
                /* Can't grow it, we don't own it. */
                b->yy_ch_buf = NULL;

            if (!b->yy_ch_buf)
                YY_FATAL_ERROR("fatal error - scanner input buffer overflow");

            (yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];

            num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
        }

        if (num_to_read > YY_READ_BUF_SIZE)
            num_to_read = YY_READ_BUF_SIZE;

        /* Read in more data. */
        YY_INPUT((&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]), (yy_n_chars), num_to_read);

        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    if ((yy_n_chars) == 0) {
        if (number_to_move == YY_MORE_ADJ) {
            ret_val = EOB_ACT_END_OF_FILE;
            yyrestart(yyin);
        }

        else {
            ret_val = EOB_ACT_LAST_MATCH;
            YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_EOF_PENDING;
        }
    }

    else
        ret_val = EOB_ACT_CONTINUE_SCAN;

    if (((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
        /* Extend the array by 50%, plus the number we really need. */
        int new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
        YY_CURRENT_BUFFER_LVALUE->yy_ch_buf =
            (char*)yyrealloc((void*)YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t)new_size);
        if (!YY_CURRENT_BUFFER_LVALUE->yy_ch_buf)
            YY_FATAL_ERROR("out of dynamic memory in yy_get_next_buffer()");
        /* "- 2" to take care of EOB's */
        YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int)(new_size - 2);
    }

    (yy_n_chars) += number_to_move;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
    YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;

    (yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];

    return ret_val;
}


/* yy_get_previous_state - get the state just before the EOB char was reached */

/* %if-c-only */
/* %not-for-header */
static yy_state_type yy_get_previous_state(void)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    yy_state_type yy_current_state;
    char* yy_cp;

    /* %% [15.0] code to get the start state into yy_current_state goes here */
    yy_current_state = (yy_start);

    for (yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp) {
        /* %% [16.0] code to find the next state goes here */
        YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
        if (yy_accept[yy_current_state]) {
            (yy_last_accepting_state) = yy_current_state;
            (yy_last_accepting_cpos) = yy_cp;
        }
        while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
            yy_current_state = (int)yy_def[yy_current_state];
            if (yy_current_state >= 336)
                yy_c = yy_meta[yy_c];
        }
        yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    }

    return yy_current_state;
}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */
/* %if-c-only */
static yy_state_type yy_try_NUL_trans(yy_state_type yy_current_state)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    int yy_is_jam;
    /* %% [17.0] code to find the next state, and perhaps do backing up, goes here */
    char* yy_cp = (yy_c_buf_p);

    YY_CHAR yy_c = 1;
    if (yy_accept[yy_current_state]) {
        (yy_last_accepting_state) = yy_current_state;
        (yy_last_accepting_cpos) = yy_cp;
    }
    while (yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state) {
        yy_current_state = (int)yy_def[yy_current_state];
        if (yy_current_state >= 336)
            yy_c = yy_meta[yy_c];
    }
    yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
    yy_is_jam = (yy_current_state == 335);

    return yy_is_jam ? 0 : yy_current_state;
}


#ifndef YY_NO_UNPUT
/* %if-c-only */

/* %endif */
#endif

/* %if-c-only */
#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput(void)
#else
static int input(void)
#endif

/* %endif */
/* %if-c++-only */
/* %endif */
{
    int c;

    *(yy_c_buf_p) = (yy_hold_char);

    if (*(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR) {
        /* yy_c_buf_p now points to the character we want to return.
         * If this occurs *before* the EOB characters, then it's a
         * valid NUL; if not, then we've hit the end of the buffer.
         */
        if ((yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)])
            /* This was really a NUL. */
            *(yy_c_buf_p) = '\0';

        else { /* need more input */
            int offset = (int)((yy_c_buf_p) - (yytext_ptr));
            ++(yy_c_buf_p);

            switch (yy_get_next_buffer()) {
                case EOB_ACT_LAST_MATCH:
                    /* This happens because yy_g_n_b()
                     * sees that we've accumulated a
                     * token and flags that we need to
                     * try matching the token before
                     * proceeding.  But for input(),
                     * there's no matching to consider.
                     * So convert the EOB_ACT_LAST_MATCH
                     * to EOB_ACT_END_OF_FILE.
                     */

                    /* Reset buffer status. */
                    yyrestart(yyin);

                    /*FALLTHROUGH*/

                case EOB_ACT_END_OF_FILE: {
                    if (yywrap())
                        return 0;

                    if (!(yy_did_buffer_switch_on_eof))
                        YY_NEW_FILE;
#ifdef __cplusplus
                    return yyinput();
#else
                    return input();
#endif
                }

                case EOB_ACT_CONTINUE_SCAN:
                    (yy_c_buf_p) = (yytext_ptr) + offset;
                    break;
            }
        }
    }

    c = *(unsigned char*)(yy_c_buf_p); /* cast for 8-bit char's */
    *(yy_c_buf_p) = '\0';              /* preserve yytext */
    (yy_hold_char) = *++(yy_c_buf_p);

    /* %% [19.0] update BOL and yylineno */

    return c;
}
/* %if-c-only */
#endif /* ifndef YY_NO_INPUT */
       /* %endif */

/** Immediately switch to a different input stream.
 * @param input_file A readable stream.
 *
 * @note This function does not reset the start condition to @c INITIAL .
 */
/* %if-c-only */
void yyrestart(FILE* input_file)
/* %endif */
/* %if-c++-only */
/* %endif */
{

    if (!YY_CURRENT_BUFFER) {
        yyensure_buffer_stack();
        YY_CURRENT_BUFFER_LVALUE = yy_create_buffer(yyin, YY_BUF_SIZE);
    }

    yy_init_buffer(YY_CURRENT_BUFFER, input_file);
    yy_load_buffer_state();
}

/* %if-c++-only */
/* %endif */

/** Switch to a different input buffer.
 * @param new_buffer The new input buffer.
 *
 */
/* %if-c-only */
void yy_switch_to_buffer(YY_BUFFER_STATE new_buffer)
/* %endif */
/* %if-c++-only */
/* %endif */
{

    /* TODO. We should be able to replace this entire function body
     * with
     *		yypop_buffer_state();
     *		yypush_buffer_state(new_buffer);
     */
    yyensure_buffer_stack();
    if (YY_CURRENT_BUFFER == new_buffer)
        return;

    if (YY_CURRENT_BUFFER) {
        /* Flush out information for old buffer. */
        *(yy_c_buf_p) = (yy_hold_char);
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    YY_CURRENT_BUFFER_LVALUE = new_buffer;
    yy_load_buffer_state();

    /* We don't actually know whether we did this switch during
     * EOF (yywrap()) processing, but the only time this flag
     * is looked at is after yywrap() is called, so it's safe
     * to go ahead and always set it.
     */
    (yy_did_buffer_switch_on_eof) = 1;
}


/* %if-c-only */
static void yy_load_buffer_state(void)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    (yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
    (yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
    /* %if-c-only */
    yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
    /* %endif */
    /* %if-c++-only */
    /* %endif */
    (yy_hold_char) = *(yy_c_buf_p);
}

/** Allocate and initialize an input buffer state.
 * @param file A readable stream.
 * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
 *
 * @return the allocated buffer state.
 */
/* %if-c-only */
YY_BUFFER_STATE yy_create_buffer(FILE* file, int size)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    YY_BUFFER_STATE b;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_buf_size = size;

    /* yy_ch_buf has to be 2 characters longer than the size given because
     * we need to put in 2 end-of-buffer characters.
     */
    b->yy_ch_buf = (char*)yyalloc((yy_size_t)(b->yy_buf_size + 2));
    if (!b->yy_ch_buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_create_buffer()");

    b->yy_is_our_buffer = 1;

    yy_init_buffer(b, file);

    return b;
}

/* %if-c++-only */
/* %endif */

/** Destroy the buffer.
 * @param b a buffer created with yy_create_buffer()
 *
 */
/* %if-c-only */
void yy_delete_buffer(YY_BUFFER_STATE b)
/* %endif */
/* %if-c++-only */
/* %endif */
{

    if (!b)
        return;

    if (b == YY_CURRENT_BUFFER) /* Not sure if we should pop here. */
        YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE)0;

    if (b->yy_is_our_buffer)
        yyfree((void*)b->yy_ch_buf);

    yyfree((void*)b);
}


/* Initializes or reinitializes a buffer.
 * This function is sometimes called more than once on the same buffer,
 * such as during a yyrestart() or at EOF.
 */
/* %if-c-only */
static void yy_init_buffer(YY_BUFFER_STATE b, FILE* file)
/* %endif */
/* %if-c++-only */
/* %endif */

{
    int oerrno = errno;

    yy_flush_buffer(b);

    /* %if-c-only */
    b->yy_input_file = file;
    /* %endif */
    /* %if-c++-only */
    /* %endif */
    b->yy_fill_buffer = 1;

    /* If b is the current buffer, then yy_init_buffer was _probably_
     * called from yyrestart() or through yy_get_next_buffer.
     * In that case, we don't want to reset the lineno or column.
     */
    if (b != YY_CURRENT_BUFFER) {
        b->yy_bs_lineno = 1;
        b->yy_bs_column = 0;
    }

    /* %if-c-only */


    b->yy_is_interactive = 0;


    /* %endif */
    /* %if-c++-only */
    /* %endif */
    errno = oerrno;
}

/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
 * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
 *
 */
/* %if-c-only */
void yy_flush_buffer(YY_BUFFER_STATE b)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    if (!b)
        return;

    b->yy_n_chars = 0;

    /* We always need two end-of-buffer characters.  The first causes
     * a transition to the end-of-buffer state.  The second causes
     * a jam in that state.
     */
    b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
    b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

    b->yy_buf_pos = &b->yy_ch_buf[0];

    b->yy_at_bol = 1;
    b->yy_buffer_status = YY_BUFFER_NEW;

    if (b == YY_CURRENT_BUFFER)
        yy_load_buffer_state();
}

/* %if-c-or-c++ */
/** Pushes the new state onto the stack. The new state becomes
 *  the current state. This function will allocate the stack
 *  if necessary.
 *  @param new_buffer The new state.
 *
 */
/* %if-c-only */
void yypush_buffer_state(YY_BUFFER_STATE new_buffer)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    if (new_buffer == NULL)
        return;

    yyensure_buffer_stack();

    /* This block is copied from yy_switch_to_buffer. */
    if (YY_CURRENT_BUFFER) {
        /* Flush out information for old buffer. */
        *(yy_c_buf_p) = (yy_hold_char);
        YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
        YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
    }

    /* Only push if top exists. Otherwise, replace top. */
    if (YY_CURRENT_BUFFER)
        (yy_buffer_stack_top)++;
    YY_CURRENT_BUFFER_LVALUE = new_buffer;

    /* copied from yy_switch_to_buffer. */
    yy_load_buffer_state();
    (yy_did_buffer_switch_on_eof) = 1;
}
/* %endif */


/* %if-c-or-c++ */
/** Removes and deletes the top of the stack, if present.
 *  The next element becomes the new top.
 *
 */
/* %if-c-only */
void yypop_buffer_state(void)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    if (!YY_CURRENT_BUFFER)
        return;

    yy_delete_buffer(YY_CURRENT_BUFFER);
    YY_CURRENT_BUFFER_LVALUE = NULL;
    if ((yy_buffer_stack_top) > 0)
        --(yy_buffer_stack_top);

    if (YY_CURRENT_BUFFER) {
        yy_load_buffer_state();
        (yy_did_buffer_switch_on_eof) = 1;
    }
}
/* %endif */


/* %if-c-or-c++ */
/* Allocates the stack if it does not exist.
 *  Guarantees space for at least one push.
 */
/* %if-c-only */
static void yyensure_buffer_stack(void)
/* %endif */
/* %if-c++-only */
/* %endif */
{
    yy_size_t num_to_alloc;

    if (!(yy_buffer_stack)) {

        /* First allocation is just for 2 elements, since we don't know if this
         * scanner will even need a stack. We use 2 instead of 1 to avoid an
         * immediate realloc on the next call.
         */
        num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
        (yy_buffer_stack) = (struct yy_buffer_state**)yyalloc(num_to_alloc * sizeof(struct yy_buffer_state*));
        if (!(yy_buffer_stack))
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");


        memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));

        (yy_buffer_stack_max) = num_to_alloc;
        (yy_buffer_stack_top) = 0;
        return;
    }

    if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1) {

        /* Increase the buffer to prepare for a possible push. */
        yy_size_t grow_size = 8 /* arbitrary grow size */;

        num_to_alloc = (yy_buffer_stack_max) + grow_size;
        (yy_buffer_stack) =
            (struct yy_buffer_state**)yyrealloc((yy_buffer_stack), num_to_alloc * sizeof(struct yy_buffer_state*));
        if (!(yy_buffer_stack))
            YY_FATAL_ERROR("out of dynamic memory in yyensure_buffer_stack()");

        /* zero only the new slots.*/
        memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
        (yy_buffer_stack_max) = num_to_alloc;
    }
}
/* %endif */


/* %if-c-only */
/** Setup the input buffer state to scan directly from a user-specified character buffer.
 * @param base the character buffer
 * @param size the size in bytes of the character buffer
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_buffer(char* base, yy_size_t size)
{
    YY_BUFFER_STATE b;

    if (size < 2 || base[size - 2] != YY_END_OF_BUFFER_CHAR || base[size - 1] != YY_END_OF_BUFFER_CHAR)
        /* They forgot to leave room for the EOB's. */
        return NULL;

    b = (YY_BUFFER_STATE)yyalloc(sizeof(struct yy_buffer_state));
    if (!b)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_buffer()");

    b->yy_buf_size = (int)(size - 2); /* "- 2" to take care of EOB's */
    b->yy_buf_pos = b->yy_ch_buf = base;
    b->yy_is_our_buffer = 0;
    b->yy_input_file = NULL;
    b->yy_n_chars = b->yy_buf_size;
    b->yy_is_interactive = 0;
    b->yy_at_bol = 1;
    b->yy_fill_buffer = 0;
    b->yy_buffer_status = YY_BUFFER_NEW;

    yy_switch_to_buffer(b);

    return b;
}
/* %endif */


/* %if-c-only */
/** Setup the input buffer state to scan a string. The next call to yylex() will
 * scan from a @e copy of @a str.
 * @param yystr a NUL-terminated string to scan
 *
 * @return the newly allocated buffer state object.
 * @note If you want to scan bytes that may contain NUL values, then use
 *       yy_scan_bytes() instead.
 */
YY_BUFFER_STATE yy_scan_string(const char* yystr)
{

    return yy_scan_bytes(yystr, (int)strlen(yystr));
}
/* %endif */


/* %if-c-only */
/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
 * scan from a @e copy of @a bytes.
 * @param yybytes the byte buffer to scan
 * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
 *
 * @return the newly allocated buffer state object.
 */
YY_BUFFER_STATE yy_scan_bytes(const char* yybytes, int _yybytes_len)
{
    YY_BUFFER_STATE b;
    char* buf;
    yy_size_t n;
    int i;

    /* Get memory for full buffer, including space for trailing EOB's. */
    n = (yy_size_t)(_yybytes_len + 2);
    buf = (char*)yyalloc(n);
    if (!buf)
        YY_FATAL_ERROR("out of dynamic memory in yy_scan_bytes()");

    for (i = 0; i < _yybytes_len; ++i)
        buf[i] = yybytes[i];

    buf[_yybytes_len] = buf[_yybytes_len + 1] = YY_END_OF_BUFFER_CHAR;

    b = yy_scan_buffer(buf, n);
    if (!b)
        YY_FATAL_ERROR("bad buffer in yy_scan_bytes()");

    /* It's okay to grow etc. this buffer, and we should throw it
     * away when we're done.
     */
    b->yy_is_our_buffer = 1;

    return b;
}
/* %endif */


#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

/* %if-c-only */
static void yynoreturn yy_fatal_error(const char* msg)
{
    fprintf(stderr, "%s\n", msg);
    exit(YY_EXIT_FAILURE);
}
/* %endif */
/* %if-c++-only */
/* %endif */

/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n)                                                                                                    \
    do {                                                                                                             \
        /* Undo effects of setting up yytext. */                                                                     \
        int yyless_macro_arg = (n);                                                                                  \
        YY_LESS_LINENO(yyless_macro_arg);                                                                            \
        yytext[yyleng] = (yy_hold_char);                                                                             \
        (yy_c_buf_p) = yytext + yyless_macro_arg;                                                                    \
        (yy_hold_char) = *(yy_c_buf_p);                                                                              \
        *(yy_c_buf_p) = '\0';                                                                                        \
        yyleng = yyless_macro_arg;                                                                                   \
    } while (0)


/* Accessor  methods (get/set functions) to struct members. */

/* %if-c-only */
/* %if-reentrant */
/* %endif */


/** Get the current line number.
 *
 */
int yyget_lineno(void)
{


    return yylineno;
}


/** Get the input stream.
 *
 */
FILE* yyget_in(void)
{
    return yyin;
}


/** Get the output stream.
 *
 */
FILE* yyget_out(void)
{
    return yyout;
}


/** Get the length of the current token.
 *
 */
int yyget_leng(void)
{
    return yyleng;
}


/** Get the current token.
 *
 */

char* yyget_text(void)
{
    return yytext;
}


/* %if-reentrant */
/* %endif */


/** Set the current line number.
 * @param _line_number line number
 *
 */
void yyset_lineno(int _line_number)
{


    yylineno = _line_number;
}


/** Set the input stream. This does not discard the current
 * input buffer.
 * @param _in_str A readable stream.
 *
 * @see yy_switch_to_buffer
 */
void yyset_in(FILE* _in_str)
{
    yyin = _in_str;
}


void yyset_out(FILE* _out_str)
{
    yyout = _out_str;
}


int yyget_debug(void)
{
    return yy_flex_debug;
}


void yyset_debug(int _bdebug)
{
    yy_flex_debug = _bdebug;
}

/* %endif */

/* %if-reentrant */
/* %if-bison-bridge */
/* %endif */
/* %endif if-c-only */

/* %if-c-only */
static int yy_init_globals(void)
{
    /* Initialization is the same as for the non-reentrant scanner.
     * This function is called from yylex_destroy(), so don't allocate here.
     */


    (yy_buffer_stack) = NULL;
    (yy_buffer_stack_top) = 0;
    (yy_buffer_stack_max) = 0;
    (yy_c_buf_p) = NULL;
    (yy_init) = 0;
    (yy_start) = 0;


/* Defined in main.c */
#ifdef YY_STDINIT
    yyin = stdin;
    yyout = stdout;
#else
    yyin = NULL;
    yyout = NULL;
#endif

    /* For future reference: Set errno on error, since we are called by
     * yylex_init()
     */
    return 0;
}
/* %endif */


/* %if-c-only SNIP! this currently causes conflicts with the c++ scanner */
/* yylex_destroy is for both reentrant and non-reentrant scanners. */
int yylex_destroy(void)
{

    /* Pop the buffer stack, destroying each element. */
    while (YY_CURRENT_BUFFER) {
        yy_delete_buffer(YY_CURRENT_BUFFER);
        YY_CURRENT_BUFFER_LVALUE = NULL;
        yypop_buffer_state();
    }

    /* Destroy the stack itself. */
    yyfree((yy_buffer_stack));
    (yy_buffer_stack) = NULL;


    /* Reset the globals. This is important in a non-reentrant scanner so the next time
     * yylex() is called, initialization will occur. */
    yy_init_globals();

    /* %if-reentrant */
    /* %endif */
    return 0;
}
/* %endif */


/*
 * Internal utility routines.
 */


#ifndef yytext_ptr
static void yy_flex_strncpy(char* s1, const char* s2, int n)
{

    int i;
    for (i = 0; i < n; ++i)
        s1[i] = s2[i];
}
#endif


#ifdef YY_NEED_STRLEN
static int yy_flex_strlen(const char* s)
{
    int n;
    for (n = 0; s[n]; ++n)
        ;

    return n;
}
#endif


void* yyalloc(yy_size_t size)
{
    return malloc(size);
}


void* yyrealloc(void* ptr, yy_size_t size)
{

    /* The cast to (char *) in the following accommodates both
     * implementations that use char* generic pointers, and those
     * that use void* generic pointers.  It works with the latter
     * because both ANSI C and C++ allow castless assignment from
     * any pointer type to void*, and deal with argument conversions
     * as though doing an assignment.
     */
    return realloc(ptr, size);
}


void yyfree(void* ptr)
{
    free((char*)ptr); /* see yyrealloc() for (char *) cast */
}


/* %if-tables-serialization definitions */
/* %define-yytables   The name for this specific scanner's tables. */
#define YYTABLES_NAME "yytables"
/* %endif */


/* %ok-for-header */


void realm::query_parser::ParserDriver::scan_begin(bool trace_scanning)
{
    yy_flex_debug = trace_scanning;
    YY_BUFFER_STATE bp;
    bp = yy_scan_bytes(parse_string.c_str(), int(parse_string.size()));
    yy_switch_to_buffer(bp);
    scan_buffer = (void*)bp;
}

void realm::query_parser::ParserDriver::scan_end()
{
    yy_delete_buffer((YY_BUFFER_STATE)scan_buffer);
}
