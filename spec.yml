# yaml-language-server: $schema=generated/spec.schema.json

headers:
  - "realm/object-store/shared_realm.hpp"
  - "realm/object-store/object_store.hpp"
  - "realm/object-store/object_schema.hpp"
  - "realm/object-store/results.hpp"
  - "realm/object-store/thread_safe_reference.hpp"
  - "realm/object-store/util/scheduler.hpp"
  - "realm/object-store/collection_notifications.hpp"
  - "realm/object-store/impl/object_notifier.hpp"
  - "realm/object-store/impl/realm_coordinator.hpp"

primitives:
  # TODO need to distinguish 64bit types where all bits are needed vs where double would be fine
  - int32_t
  - int64_t
  - uint64_t
  - count_t # size_t but only used for counts (so never > 2**52)
  - double
  - float
  - bool
  - int
  - void
  - std::string
  # TODO: see if we need nullable versions of these. For now null buffers are treated as empty.
  - StringData
  - OwnedBinaryData
  - BinaryData

typeAliases:
  uint_fast64_t: uint64_t
  Schema: std::vector<ObjectSchema>
  KeyPath: std::vector<std::pair<TableKey, ColKey>>
  KeyPathArray: std::vector<KeyPath>


templates: # value tells you how many arguments it takes ('*' means any number)
  util::Optional: 1
  std::vector: 1
  std::shared_ptr: 1
  std::pair: 2
  std::tuple: '*'

enums:
  SchemaMode:
    values:
      - Automatic
      - Immutable
      - ReadOnlyAlternative
      - ResetFile
      - AdditiveDiscovered
      - AdditiveExplicit
      - Manual

  PropertyType:
    isFlag: true
    flagMask: 960
    values:
      Int: 0
      Bool: 1
      String: 2
      Data: 3
      Date: 4
      Float: 5
      Double: 6
      Object: 7         # currently must be either Array xor Nullable
      LinkingObjects: 8 # currently must be Array and not Nullable

      Mixed: 9
      ObjectId: 10
      Decimal: 11
      UUID: 12

      # Flags which can be combined with any of the above types except as noted
      Required: 0
      Nullable: 64
      Array: 128
      Set: 256
      Dictionary: 512

      Collection: 896 # Array | Set | Dictionary
      Flags: 960 # Nullable | Collection

  TableType:
    cppName: ObjectSchema::ObjectType
    values:
      TopLevel: 0
      Embedded: 1
      TopLevelAsymmetric: 0x2 

  DataType:
    values:
      Int: 0
      Bool: 1
      String: 2
      Binary: 4
      Mixed: 6
      Timestamp: 8
      Float: 9
      Double: 10
      Decimal: 11
      Link: 12
      LinkList: 13
      ObjectId: 15
      TypedLink: 16
      UUID: 17

constants:
  null_col_key:
    type: int64_t
    value: 0x7FFF_FFFF_FFFF_FFFF

records:
  Property:
    fields:
      name: std::string
      public_name:
        type: std::string
        default: ""
      type:
        type: PropertyType
      object_type:
        type: std::string
        default: ""
      link_origin_property_name:
        type: std::string
        default: ""
      is_primary: 
        type: bool
        default: false
      is_indexed:
        type: bool
        default: false
      column_key: 
        type: ColKey
        default: {}
  VersionID:
    fields:
      version:
        type: int64_t
        default: 0x7FFF_FFFF_FFFF_FFFF
      index:
        type: int32_t
        default: 0
  ColKey:
    fields:
      value:
        type: int64_t
        default: 0x7FFF_FFFF_FFFF_FFFF
  ObjKey:
    fields:
      value:
        type: int64_t
        default: 0x7FFF_FFFF_FFFF_FFFF
  TableKey:
    fields:
      value:
        type: int32_t
        default: 0x7FFF_FFFF
  ObjectSchema:
    fields:
      name: std::string
      persisted_properties:
        type: std::vector<Property>
        default: []
      computed_properties:
        type: std::vector<Property>
        default: []
      primary_key:
        type: std::string
        default: ''
      table_key:
        type: TableKey
        default: {}
      table_type:
        type: TableType
        default: TopLevel
      alias:
        type: std::string
        default: ''

  RealmConfig:
    fields:
      path: std::string
      # realm_data: BinaryData
      #encryption_key:
        #type: std::vector<char>
        #default: {}
      fifo_files_fallback_path:
        type: std::string
        default: ""
      in_memory:
        type: bool
        default: false
      schema:
        type: util::Optional<Schema>
        default: {}
      schema_version:
        type: uint64_t
        default: -1
      schema_mode:
        type: SchemaMode
        default: SchemaMode::Automatic

      # migration_function
      initialization_function:
        type: '(realm: SharedRealm) -> void'
        default: {}
      should_compact_on_launch_function:
        type: '(total_bytes: uint64_t, used_bytes: uint64_t) -> bool'
        default: {}

  ObjectChangeSet:
    fields:
      is_deleted: bool
      changed_columns: std::vector<ColKey>

opaqueTypes:
  - Group
  - AuditInterface

classes:
  #ThreadSafeReference: {}
  #SchemaChange: {}

  Helpers:
    staticMethods:
      get_table:
        - '(r: SharedRealm, key: TableKey) -> TableRef'
        - sig: '(r: SharedRealm, name: StringData) -> TableRef'
          suffix: by_name
      get_keypath_mapping: '(r: SharedRealm) -> KeyPathMapping'
      results_from_query: '(r: SharedRealm, q: Query) -> Results'
      make_object_notifier: '(r: SharedRealm, o: Obj) -> SharedObjectNotifier'

  TableRef:
    needsDeref: true
    iterable: Obj
    properties:
      get_name: StringData
      get_column_count: count_t
    methods:
      is_embedded: () const -> bool
      get_column_type: '(column: ColKey) const -> DataType'
      get_link_target: '(column: ColKey) const -> TableRef'
      create_object: () -> Obj
      create_object_with_primary_key: '(pk: Mixed) -> Obj'
      get_object: '(key: ObjKey) const -> Obj'
      get_object_with_primary_key: '(pk: Mixed) const -> Obj'
      try_get_object: '(key: ObjKey) const -> Obj'
      query: '(query_string: std::string, args: std::vector<Mixed>, mapping: KeyPathMapping) const -> Query'
      remove_object: '(key: ObjKey)'

  Obj:
    properties:
      is_valid: bool
      get_table: TableRef
      get_key: ObjKey
      get_link: ObjLink
      get_primary_key: Mixed
    methods:
      get_any:
        - '(column: ColKey) const -> Mixed'
        - sig: '(column: StringData) const -> Mixed'
          suffix: 'by_name'
      is_null:
        - '(column: ColKey) const -> bool'
        - sig: '(column: StringData) const -> bool'
          suffix: by_name
      set_any: # NOTE: ignoring ability to chain calls
        - '(column: ColKey, value: Mixed)'
        - sig: '(column: ColKey, value: Mixed, is_default: bool)'
          suffix: with_default
      get_linked_object: '(column: ColKey) const -> Obj'
      to_string: () const -> std::string

  Transaction:
    sharedPtrWrapped: TransactionRef

  ObjectStore:
    staticMethods:
      get_schema_version: '(group: Group) -> uint64_t'
      set_schema_version: '(group: Group, version: uint64_t)'
      #    verify_no_migration_required: '(changes: std::vector<SchemaChange>)'
      #needs_migration: '(changes: std::vector<SchemaChange>) -> bool'
      #verify_valid_additive_changes:
      #  - '(changes: std::vector<SchemaChange>) -> bool'
      #  - suffix: and_update_indexes
      #    sig: '(changes: std::vector<SchemaChange>, update_indexes: bool) -> bool'
      #verify_valid_external_changes: '(changes: std::vector<SchemaChange>)'
      #verify_compatible_for_immutable_and_readonly: '(changes: std::vector<SchemaChange>)'
      #verify_no_changes_required: '(changes: std::vector<SchemaChange>)'

      # apply_schema_changes: '(group: Transaction&, uint64_t: schema_version, target_schema: Schema&, target_schema_version: uint64_t, mode: SchemaMode, changes: std::vector<SchemaChange>, migration_function: () -> void)'
      # apply_additive_changes: '(group: Group&, changes: std::vector<SchemaChanges>, update_indexes: bool)'
      # table_for_object_type
      # table_for_Schema_type
      
      schema_from_group: '(group: Group) -> Schema'

      # some more...

  Mixed:
    #TODO may want to make this a primitive. Need to think about how to handle 'float' since js doesn't preserve it
    constructors:
      from_null: ()
      from_int: '(v: int)'
      from_int64_t: '(v: int64_t)'
      from_bool: '(v: bool)'
      from_float: '(v: float)'
      from_double: '(v: double)'
      #TODO do we want to list optional<T> ctors here?
      from_timestamp: '(v: Timestamp)'
      from_decimal128: '(v: Decimal128)'
      from_objectid: '(v: ObjectId)'
      from_objkey: '(v: ObjKey)'
      from_obj: '(v: const Obj&)'
      from_link: '(v: ObjLink)'
      from_uuid: '(v: UUID)'
      from_binary: '(v: BinaryData)'

      # Warning: This requires some special workarounds because it is a view.
      from_string: '(v: StringData)'

    properties:
      get_type: DataType

    methods:
      is_type: '(type: DataType) const -> bool' # Not supporting varargs. Could if needed.

      # Intentionally not making these properties since they are fallable converters.
      get_int: '() const -> int64_t'
      get_bool: '() const -> bool'
      get_float: '() const -> float'
      get_double: '() const -> double'
      get_string: '() const -> StringData'
      get_binary: '() const -> BinaryData'
      get_timestamp: '() const -> Timestamp'
      get_decimal: '() const -> Decimal128'
      get_object_id: '() const -> ObjectId'
      get_uuid: '() const -> UUID'
      get_link: '() const -> ObjLink'

      is_null: '() const -> bool'
      accumulate_numeric_to: '(destination: Decimal128&) const -> bool'
      is_unresolved_link: '() const -> bool'
      is_same_type: '(b: Mixed) const -> bool'
      compare: '(b: Mixed) const -> int'
      compare_signed: '(b: Mixed) const -> int'
      #hash: '() const -> size_t' # TODO decide what to do about size_t

    staticMethods:
      is_numeric: '(type: DataType) -> bool' # Not supporting varargs. Could if needed.
      types_are_comparable: '(l: Mixed, r: Mixed) -> bool'
      data_types_are_comparable: '(l: DataType, r: DataType) -> bool'


  Timestamp: {}
  ObjectId: {}
  Decimal128: {}
  UUID: {}

  ObjLink:
    properties:
      is_null: bool
      is_unresolved: bool
      get_table_key: TableKey
      get_obj_key: ObjKey

  KeyPathMapping:
    cppName: query_parser::KeyPathMapping

  Query:
    methods:
      count: () const -> count_t

  SortDescriptor:
    constructors:
      make_empty: ()
      make: '(column_indices: std::vector<std::vector<ColKey>>, ascending: std::vector<bool>)'
    properties:
      is_valid: bool

  Results:
    constructors:
      make_empty: ()
      from_table: '(r: SharedRealm, table: TableRef)'
      # from_query: '(r: SharedRealm, query: Query, ordering: DescriptorOrdering)'
    properties:
      is_frozen: bool
      is_valid: bool
      get_query: Query
      #get_ordering: const DescriptorOrdering&
      get_object_type: StringData
      get_type: PropertyType
    methods:
      size: () -> count_t
      get: # NOTE: this is actually a template with a defaulted template param.
        - sig: '(index: count_t) -> Obj'
          suffix: 'obj'
      get_any: '(index: count_t) -> Mixed'
      get_dictionary_element: '(index: count_t) -> std::pair<StringData, Mixed>'
      filter: '(query: Query&&) const -> Results'
      sort:
        - '(order: SortDescriptor&&) const -> Results'
        - sig: '(order: std::vector<std::pair<std::string, bool>>) const -> Results'
          suffix: by_names
      limit: '(max_count: count_t) const -> Results'
      snapshot: '() const -> Results'
      freeze: '(frozen_realm: SharedRealm) const -> Results'
      max: '(column: ColKey) -> util::Optional<Mixed>'
      min: '(column: ColKey) -> util::Optional<Mixed>'
      average: '(column: ColKey) -> util::Optional<Mixed>'
      sum: '(column: ColKey) -> util::Optional<Mixed>'

  Realm:
    sharedPtrWrapped: SharedRealm

    staticMethods:
      get_shared_realm:
        - '(config: RealmConfig) -> SharedRealm'
        #- suffix: for_thread
          #sig: '(thread: ThreadSafeReference) -> SharedRealm'
        #- suffix: for_thread_with_sched
          #sig: '(thread: ThreadSafeReference, scheduler: std::shared_ptr<util::Scheduler>) -> SharedRealm'
      #make_shared_realm: '(config: Realm::Config, version: util::Optional<VersionID>, coordinator: std::shared_ptr<_impl::RealmCoordinator>) -> SharedRealm'

    properties:
      config: const RealmConfig&
      schema: const Schema&
      schema_version: uint64_t
      is_in_transaction: bool
      is_frozen: bool
      is_in_migration: bool

      get_number_of_versions: uint64_t
      read_transaction_version: VersionID
      current_transaction_version: util::Optional<VersionID>

      auto_refresh: bool

      can_deliver_notifications: bool
      scheduler: std::shared_ptr<Scheduler>
      
      is_closed: bool

      audit_context: AuditInterface*

    methods:
      begin_transaction: ()
      commit_transaction: ()
      cancel_transaction: ()
      freeze: () -> SharedRealm
      last_seen_transaction_version: () -> uint64_t
      read_group: () -> Group&
      duplicate: () -> TransactionRef

      enable_wait_for_change: ()
      wait_for_change: () -> bool
      wait_for_change_release: ()
      refresh: () -> bool
      set_auto_refresh: '(auto_refresh: bool)'
      notify: ()
      invalidate: ()
      compact: () -> bool
      write_copy: () -> OwnedBinaryData

      verify_thread: () const
      verify_in_write: () const
      verify_open: () const
      verify_notifications_available:
        - () const
        - suffix: maybe_throw
          sig: '(throw_on_error: bool) const'

      close: ()

  NotificationToken:
    #TODO need a way to destroy this or at least assign over it with a default constructed token
    constructors:
      for_object: '(notifier: SharedObjectNotifier, token: uint64_t)'
    methods:
      suppress_next: ()

  ObjectNotifier:
    cppName: _impl::ObjectNotifier
    sharedPtrWrapped: SharedObjectNotifier
    constructors:
      make: '(realm: SharedRealm, table: TableKey, obj: ObjKey)'
    methods:
      # Pass return to NotificationToken constructor
      add_callback: '(cb: (changes: ObjectChangeSet), keyPaths: KeyPathArray) -> uint64_t'

interfaces:
  Scheduler:
    cppName: util::Scheduler
    methods:
      invoke: '(callback: () -> void)'
      is_on_thread: () const noexcept -> bool
      is_same_as: '(other: const Scheduler*) const noexcept -> bool'
      can_invoke: () const noexcept -> bool
    staticMethods:
      make_frozen: '(version: VersionID) -> std::shared_ptr<Scheduler>'
      make_default: '() -> std::shared_ptr<Scheduler>'
      set_default_factory: '(factory: () -> std::shared_ptr<Scheduler>)'
