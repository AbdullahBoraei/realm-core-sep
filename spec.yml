# yaml-language-server: $schema=generated/spec.schema.json

headers:
  - "realm/object-store/shared_realm.hpp"
  - "realm/object-store/object_store.hpp"
  - "realm/object-store/object_schema.hpp"
  - "realm/object-store/results.hpp"
  - "realm/object-store/thread_safe_reference.hpp"
  - "realm/object-store/util/scheduler.hpp"
  - "realm/object-store/collection_notifications.hpp"
  - "realm/object-store/impl/object_notifier.hpp"
  - "realm/object-store/impl/realm_coordinator.hpp"

primitives:
  # TODO need to distinguish 64bit types where all bits are needed vs where double would be fine
  - int32_t
  - int64_t
  - uint64_t
  - count_t # size_t but only used for counts (so never > 2**52)
  - double
  - float
  - bool
  - void
  - std::string
  # TODO: see if we need nullable versions of these. For now null buffers are treated as empty.
  - StringData
  - OwnedBinaryData
  - BinaryData
  - Mixed
  - ObjectId
  - Decimal128
  - UUID
  - EncryptionKey # vector<char> in C++, but should have API of OwnedBinaryData in SDK
                  # TODO consider changing type in realm-core.

typeAliases:
  int: int32_t
  Schema: std::vector<ObjectSchema>
  KeyPath: std::vector<std::pair<TableKey, ColKey>>
  KeyPathArray: std::vector<KeyPath>
  IndexRange: std::pair<count_t, count_t>


templates: # value tells you how many arguments it takes ('*' means any number)
  util::Optional: 1
  std::vector: 1
  std::shared_ptr: 1
  std::pair: 2
  std::tuple: '*'
  # std::unordered_map: 2

mixedInfo:
  dataTypes:
    Int:
      getter: get_int
      type: int64_t
    Bool:
      getter: get_bool
      type: bool
    Float:
      getter: get_float
      type: float
    Double:
      getter: get_double
      type: double
    String:
      getter: get_string
      type: StringData
    Binary:
      getter: get_binary
      type: BinaryData
    Timestamp:
      getter: get_timestamp
      type: Timestamp
    Decimal:
      getter: get_decimal
      type: Decimal128
    ObjectId:
      getter: get_object_id
      type: ObjectId
    UUID:
      getter: get_uuid
      type: UUID
    TypedLink:
      getter: get_link # get_link is for TypedLink, not Link!
      type: ObjLink
  unusedDataTypes:
    - Mixed
    - LinkList
    - Link # This can be used with get<ObjKey>(), but there are better APIs to use with link columns.
  extraCtors:
    - Obj

enums:
  SchemaMode:
    values:
      - Automatic
      - Immutable
      - ReadOnlyAlternative
      - ResetFile
      - AdditiveDiscovered
      - AdditiveExplicit
      - Manual

  PropertyType:
    isFlag: true
    flagMask: 960
    values:
      Int: 0
      Bool: 1
      String: 2
      Data: 3
      Date: 4
      Float: 5
      Double: 6
      Object: 7         # currently must be either Array xor Nullable
      LinkingObjects: 8 # currently must be Array and not Nullable

      Mixed: 9
      ObjectId: 10
      Decimal: 11
      UUID: 12

      # Flags which can be combined with any of the above types except as noted
      Required: 0
      Nullable: 64
      Array: 128
      Set: 256
      Dictionary: 512

      Collection: 896 # Array | Set | Dictionary
      Flags: 960 # Nullable | Collection

  TableType:
    cppName: ObjectSchema::ObjectType
    values:
      TopLevel: 0
      Embedded: 1
      TopLevelAsymmetric: 0x2 

  DataType:
    values:
      Int: 0
      Bool: 1
      String: 2
      Binary: 4
      Mixed: 6
      Timestamp: 8
      Float: 9
      Double: 10
      Decimal: 11
      Link: 12
      LinkList: 13
      ObjectId: 15
      TypedLink: 16
      UUID: 17

constants:
  null_col_key:
    type: int64_t
    value: 0x7FFF_FFFF_FFFF_FFFF

records:
  Property:
    fields:
      name: std::string
      public_name:
        type: std::string
        default: ""
      type:
        type: PropertyType
      object_type:
        type: std::string
        default: ""
      link_origin_property_name:
        type: std::string
        default: ""
      is_primary: 
        type: bool
        default: false
      is_indexed:
        type: bool
        default: false
      column_key: 
        type: ColKey
        default: {}
  VersionID:
    fields:
      version:
        type: int64_t
        default: 0x7FFF_FFFF_FFFF_FFFF
      index:
        type: int32_t
        default: 0
  ColKey:
    fields:
      value:
        type: int64_t
        default: 0x7FFF_FFFF_FFFF_FFFF
  ObjKey:
    fields:
      value:
        type: int64_t
        default: 0x7FFF_FFFF_FFFF_FFFF
  TableKey:
    fields:
      value:
        type: int32_t
        default: 0x7FFF_FFFF
  ObjectSchema:
    fields:
      name: std::string
      persisted_properties:
        type: std::vector<Property>
        default: []
      computed_properties:
        type: std::vector<Property>
        default: []
      primary_key:
        type: std::string
        default: ''
      table_key:
        type: TableKey
        default: {}
      table_type:
        type: TableType
        default: TopLevel
      alias:
        type: std::string
        default: ''

  RealmConfig:
    fields:
      path: std::string
      # realm_data: BinaryData
      #encryption_key:
        #type: std::vector<char>
        #default: {}
      fifo_files_fallback_path:
        type: std::string
        default: ""
      in_memory:
        type: bool
        default: false
      schema:
        type: util::Optional<Schema>
        default: {}
      schema_version:
        type: uint64_t
        default: -1
      schema_mode:
        type: SchemaMode
        default: SchemaMode::Automatic
      encryption_key:
        type: EncryptionKey
        default: {}

      # migration_function
      initialization_function:
        type: '(realm: SharedRealm) -> void'
        default: {}
      should_compact_on_launch_function:
        type: '(total_bytes: uint64_t, used_bytes: uint64_t) -> bool'
        default: {}

  ObjectChangeSet:
    fields:
      is_deleted: bool
      changed_columns: std::vector<ColKey>

  # TODO nested type?
  CollectionChangeSetMove:
    cppName: CollectionChangeSet::Move
    fields:
      from: count_t
      to: count_t
  CollectionChangeSet:
    fields:
      deletions: IndexSet
      insertions: IndexSet
      modifications: IndexSet
      modifications_new: IndexSet
      moves: std::vector<CollectionChangeSetMove>
      collection_root_was_deleted: bool
      collection_was_cleared: bool
      # columns: std::unordered_map<int64_t, IndexSet>

  DictionaryChangeSet:
    fields:
      deletions: std::vector<Mixed>
      insertions: std::vector<Mixed>
      modifications: std::vector<Mixed>
      collection_root_was_deleted: bool

opaqueTypes:
  - Group
  - AuditInterface

classes:
  #ThreadSafeReference: {}
  #SchemaChange: {}

  Helpers:
    staticMethods:
      get_table:
        - '(r: SharedRealm, key: TableKey) -> TableRef'
        - sig: '(r: SharedRealm, name: StringData) -> TableRef'
          suffix: by_name
      get_keypath_mapping: '(r: SharedRealm) -> KeyPathMapping'
      results_from_query: '(r: SharedRealm, q: Query) -> Results'
      make_object_notifier: '(r: SharedRealm, o: Obj) -> SharedObjectNotifier'

  TableRef:
    needsDeref: true
    iterable: Obj
    properties:
      get_name: StringData
      get_column_count: count_t
    methods:
      is_embedded: () const -> bool
      get_column_type: '(column: ColKey) const -> DataType'
      get_link_target: '(column: ColKey) const -> TableRef'
      create_object: () -> Obj
      create_object_with_primary_key: '(pk: Mixed) -> Obj'
      get_object: '(key: ObjKey) const -> Obj'
      get_object_with_primary_key: '(pk: Mixed) const -> Obj'
      try_get_object: '(key: ObjKey) const -> Obj'
      query: '(query_string: std::string, args: std::vector<Mixed>, mapping: KeyPathMapping) const -> Query'
      remove_object: '(key: ObjKey)'

  Obj:
    properties:
      is_valid: bool
      get_table: TableRef
      get_key: ObjKey
      get_link: ObjLink
      get_primary_key: Mixed
    methods:
      get_any:
        - '(column: ColKey) const -> Mixed'
        - sig: '(column: StringData) const -> Mixed'
          suffix: 'by_name'
      is_null:
        - '(column: ColKey) const -> bool'
        - sig: '(column: StringData) const -> bool'
          suffix: by_name
      set_any: # NOTE: ignoring ability to chain calls
        - '(column: ColKey, value: Mixed)'
        - sig: '(column: ColKey, value: Mixed, is_default: bool)'
          suffix: with_default
      get_linked_object: '(column: ColKey) const -> Obj'
      to_string: () const -> std::string

  Transaction:
    sharedPtrWrapped: TransactionRef

  ObjectStore:
    staticMethods:
      get_schema_version: '(group: Group) -> uint64_t'
      set_schema_version: '(group: Group, version: uint64_t)'
      #    verify_no_migration_required: '(changes: std::vector<SchemaChange>)'
      #needs_migration: '(changes: std::vector<SchemaChange>) -> bool'
      #verify_valid_additive_changes:
      #  - '(changes: std::vector<SchemaChange>) -> bool'
      #  - suffix: and_update_indexes
      #    sig: '(changes: std::vector<SchemaChange>, update_indexes: bool) -> bool'
      #verify_valid_external_changes: '(changes: std::vector<SchemaChange>)'
      #verify_compatible_for_immutable_and_readonly: '(changes: std::vector<SchemaChange>)'
      #verify_no_changes_required: '(changes: std::vector<SchemaChange>)'

      # apply_schema_changes: '(group: Transaction&, uint64_t: schema_version, target_schema: Schema&, target_schema_version: uint64_t, mode: SchemaMode, changes: std::vector<SchemaChange>, migration_function: () -> void)'
      # apply_additive_changes: '(group: Group&, changes: std::vector<SchemaChanges>, update_indexes: bool)'
      # table_for_object_type
      # table_for_Schema_type
      
      schema_from_group: '(group: Group) -> Schema'

      # some more...

  # TODO should this be nullable or always non-null?
  Timestamp:
    constructors:
      make: '(seconds: int64_t, nanoseconds: int32_t)'
    properties:
      get_seconds: int64_t
      get_nanoseconds: int32_t

  ObjLink:
    properties:
      is_null: bool
      is_unresolved: bool
      get_table_key: TableKey
      get_obj_key: ObjKey

  KeyPathMapping:
    cppName: query_parser::KeyPathMapping

  Query:
    methods:
      count: () const -> count_t

  SortDescriptor:
    constructors:
      make_empty: ()
      make: '(column_indices: std::vector<std::vector<ColKey>>, ascending: std::vector<bool>)'
    properties:
      is_valid: bool

  Results:
    constructors:
      make_empty: ()
      from_table: '(r: SharedRealm, table: TableRef)'
      # from_query: '(r: SharedRealm, query: Query, ordering: DescriptorOrdering)'
    properties:
      is_frozen: bool
      is_valid: bool
      get_query: Query
      #get_ordering: const DescriptorOrdering&
      get_object_type: StringData
      get_type: PropertyType
    methods:
      size: () -> count_t
      get: # NOTE: this is actually a template with a defaulted template param.
        - sig: '(index: count_t) -> Obj'
          suffix: 'obj'
      get_any: '(index: count_t) -> Mixed'
      get_dictionary_element: '(index: count_t) -> std::pair<StringData, Mixed>'
      filter: '(query: Query&&) const -> Results'
      sort:
        - '(order: SortDescriptor&&) const -> Results'
        - sig: '(order: std::vector<std::pair<std::string, bool>>) const -> Results'
          suffix: by_names
      limit: '(max_count: count_t) const -> Results'
      snapshot: '() const -> Results'
      freeze: '(frozen_realm: SharedRealm) const -> Results'
      max: '(column: ColKey) -> util::Optional<Mixed>'
      min: '(column: ColKey) -> util::Optional<Mixed>'
      average: '(column: ColKey) -> util::Optional<Mixed>'
      sum: '(column: ColKey) -> util::Optional<Mixed>'

      add_notification_callback: '(cb: (changes: const CollectionChangeSet&), keyPaths: KeyPathArray) -> NotificationToken'

  Realm:
    sharedPtrWrapped: SharedRealm

    staticMethods:
      get_shared_realm:
        - '(config: RealmConfig) -> SharedRealm'
        #- suffix: for_thread
          #sig: '(thread: ThreadSafeReference) -> SharedRealm'
        #- suffix: for_thread_with_sched
          #sig: '(thread: ThreadSafeReference, scheduler: std::shared_ptr<util::Scheduler>) -> SharedRealm'
      #make_shared_realm: '(config: Realm::Config, version: util::Optional<VersionID>, coordinator: std::shared_ptr<_impl::RealmCoordinator>) -> SharedRealm'

    properties:
      config: const RealmConfig&
      schema: const Schema&
      schema_version: uint64_t
      is_in_transaction: bool
      is_frozen: bool
      is_in_migration: bool

      get_number_of_versions: uint64_t
      read_transaction_version: VersionID
      current_transaction_version: util::Optional<VersionID>

      auto_refresh: bool

      can_deliver_notifications: bool
      scheduler: std::shared_ptr<Scheduler>
      
      is_closed: bool

      audit_context: AuditInterface*

    methods:
      begin_transaction: ()
      commit_transaction: ()
      cancel_transaction: ()
      freeze: () -> SharedRealm
      last_seen_transaction_version: () -> uint64_t
      read_group: () -> Group&
      duplicate: () -> TransactionRef

      enable_wait_for_change: ()
      wait_for_change: () -> bool
      wait_for_change_release: ()
      refresh: () -> bool
      set_auto_refresh: '(auto_refresh: bool)'
      notify: ()
      invalidate: ()
      compact: () -> bool
      write_copy: () -> OwnedBinaryData

      verify_thread: () const
      verify_in_write: () const
      verify_open: () const
      verify_notifications_available:
        - () const
        - suffix: maybe_throw
          sig: '(throw_on_error: bool) const'

      close: ()

  ObjectNotifier:
    cppName: _impl::ObjectNotifier
    sharedPtrWrapped: SharedObjectNotifier
    constructors:
      make: '(realm: SharedRealm, table: TableKey, obj: ObjKey)'
    methods:
      add_callback: '(cb: (changes: ObjectChangeSet), keyPaths: KeyPathArray) -> uint64_t'
      remove_callback: '(token: uint64_t)'

  NotificationToken:
    constructors:
      for_object: '(notifier: SharedObjectNotifier, token: uint64_t)'
    methods:
      suppress_next: ()
      unregister: ()

  IndexSet:
    iterable: IndexRange
    # methods:
    #   as_indexes: () const -> IndexSetIndexes

  # NOTE this is currently done in sdk language so we have less VM<->Native transitions.
  # TODO make this a nested type of IndexSet?
  # TODO this needs support for non-default-constructible types
  # IndexSetIndexes:
  #   cppName: IndexSet::IndexIteratableAdaptor
  #   iterable: count_t

  Collection:
    cppName: object_store::Collection
    abstract: true
    properties:
      get_type: PropertyType
      get_realm: SharedRealm
      get_parent_column_key: ColKey
      get_parent_object_key: ObjKey
      get_parent_table_key: TableKey
      size: count_t
      is_valid: bool
      is_frozen: bool
    methods:
      get_any: '(ndx: count_t) const -> Mixed'
      find_any: '(value: Mixed) const -> count_t'
      verify_attached: () const
      verify_in_transaction: () const
      as_results: () const -> Results
      snapshot: () const -> Results
      sort:
        - '(order: SortDescriptor) const -> Results'
        - sig: '(keyPaths: std::vector<std::pair<std::string, bool>> const&) const -> Results'
          suffix: 'by_name'
      add_notification_callback: '(cb: (changes: const CollectionChangeSet&), keyPaths: KeyPathArray) -> NotificationToken'

  List:
    base: Collection
    constructors:
      make: '(r: SharedRealm, parent: const Obj&, col: ColKey)'
    methods:
      get: '(ndx: count_t) const -> Obj'
      move: '(source_ndx: count_t, dest_ndx: count_t)'
      remove: '(ndx: count_t)'
      remove_all: '()'
      swap: '(ndx1: count_t, ndx2: count_t)'
      delete_at: '(ndx: count_t)'
      delete_all: '()'
      insert_any: '(list_ndx: count_t, value: Mixed)'
      set_any: '(list_ndx: count_t, value: Mixed)'
      filter: '(q: Query) const -> Results'
      freeze: '(frozen_realm: std::shared_ptr<Realm> const&) const -> List'

      max:
        - '() const -> util::Optional<Mixed>'
        - sig: '(column: ColKey) const -> util::Optional<Mixed>'
          suffix: of
      min:
        - '() const -> util::Optional<Mixed>'
        - sig: '(column: ColKey) const -> util::Optional<Mixed>'
          suffix: of
      average:
        - '() const -> util::Optional<Mixed>'
        - sig: '(column: ColKey) const -> util::Optional<Mixed>'
          suffix: of
      sum:
        - '() const -> Mixed'
        - sig: '(column: ColKey) const -> Mixed'
          suffix: of

  Set:
    cppName: object_store::Set
    base: Collection
    constructors:
      make: '(r: SharedRealm, parent: const Obj&, col: ColKey)'
    methods:
      get: '(ndx: count_t) const -> Obj'
      insert_any: '(val: Mixed) -> std::pair<count_t, bool>'
      remove_any: '(val: Mixed) -> std::pair<count_t, bool>'
      remove_all: '()'
      delete_all: '()'
      filter: '(q: Query) const -> Results'

      # TODO Anything that takes a Collection (or any other Base) isn't possible while using Napi::ObjectWrap
      # is_subset_of: '(rhs: const Collection&) const -> bool'
      # is_strict_subset_of: '(rhs: const Collection&) const -> bool'
      # is_superset_of: '(rhs: const Collection&) const -> bool'
      # is_strict_superset_of: '(rhs: const Collection&) const -> bool'
      # intersects: '(rhs: const Collection&) const -> bool'
      # set_equals: '(rhs: const Collection&) const -> bool'
      # assign_intersection: '(rhs: const Collection&) -> void'
      # assign_union: '(rhs: const Collection&) -> void'
      # assign_difference: '(rhs: const Collection&) -> void'
      # assign_symmetric_difference: '(rhs: const Collection&) -> void'

      max:
        - '() const -> util::Optional<Mixed>'
        - sig: '(column: ColKey) const -> util::Optional<Mixed>'
          suffix: of
      min:
        - '() const -> util::Optional<Mixed>'
        - sig: '(column: ColKey) const -> util::Optional<Mixed>'
          suffix: of
      average:
        - '() const -> util::Optional<Mixed>'
        - sig: '(column: ColKey) const -> util::Optional<Mixed>'
          suffix: of
      sum:
        - '() const -> Mixed'
        - sig: '(column: ColKey) const -> Mixed'
          suffix: of

  Dictionary:
    cppName: object_store::Dictionary
    base: Collection
    iterable: std::pair<const Mixed, Mixed>
    constructors:
      make: '(r: SharedRealm, parent: const Obj&, col: ColKey)'
    properties:
      get_keys: Results
      get_values: Results
    methods:
      get:
        - sig: '(key: StringData) const -> Obj'
          cppName: get<Obj> # TODO can't distinguish null from missing
      get_pair: '(ndx: count_t) const -> std::pair<StringData, Mixed>'
      contains: '(key: StringData) -> bool'
      freeze: '(frozen_realm: std::shared_ptr<Realm> const&) const -> Dictionary'
      add_key_based_notification_callback: '(cb: (changes: DictionaryChangeSet), keyPaths: KeyPathArray) -> NotificationToken'

interfaces:
  Scheduler:
    cppName: util::Scheduler
    methods:
      invoke: '(callback: () -> void)'
      is_on_thread: () const noexcept -> bool
      is_same_as: '(other: const Scheduler*) const noexcept -> bool'
      can_invoke: () const noexcept -> bool
    staticMethods:
      make_frozen: '(version: VersionID) -> std::shared_ptr<Scheduler>'
      make_default: '() -> std::shared_ptr<Scheduler>'
      set_default_factory: '(factory: () -> std::shared_ptr<Scheduler>)'
